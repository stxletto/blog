<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.stxletto.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux系统安全缺陷缓解机制现代Linux发行版提供了一些缓解技术，使更难稳定利用软件漏洞。 例如只读重定位（RELRO，RELocation Read-Only），禁止执行（NX，NoExecute），栈保护（Canaries），地址空间布局随机化（ASLR，Address Space Layout Randomization）和位置无关可执行文件（PIE，Position Independe">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统安全缺陷缓解机制">
<meta property="og:url" content="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="深澜深蓝">
<meta property="og:description" content="Linux系统安全缺陷缓解机制现代Linux发行版提供了一些缓解技术，使更难稳定利用软件漏洞。 例如只读重定位（RELRO，RELocation Read-Only），禁止执行（NX，NoExecute），栈保护（Canaries），地址空间布局随机化（ASLR，Address Space Layout Randomization）和位置无关可执行文件（PIE，Position Independe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/%E5%9B%BE-1.png">
<meta property="article:published_time" content="2020-04-28T14:44:37.357Z">
<meta property="article:modified_time" content="2020-04-28T14:46:01.341Z">
<meta property="article:author" content="stxletto">
<meta property="article:tag" content="安全">
<meta property="article:tag" content="漏洞">
<meta property="article:tag" content="分析">
<meta property="article:tag" content="威胁">
<meta property="article:tag" content="识别">
<meta property="article:tag" content="检测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/%E5%9B%BE-1.png">

<link rel="canonical" href="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux系统安全缺陷缓解机制 | 深澜深蓝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">深澜深蓝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>作品</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stxletto">
      <meta itemprop="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深澜深蓝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux系统安全缺陷缓解机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-28 22:44:37 / 修改时间：22:46:01" itemprop="dateCreated datePublished" datetime="2020-04-28T22:44:37+08:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Linux系统安全缺陷缓解机制"><a href="#Linux系统安全缺陷缓解机制" class="headerlink" title="Linux系统安全缺陷缓解机制"></a>Linux系统安全缺陷缓解机制</h1><p>现代Linux发行版提供了一些缓解技术，使更难稳定利用软件漏洞。 例如只读重定位（RELRO，RELocation Read-Only），禁止执行（NX，NoExecute），栈保护（Canaries），地址空间布局随机化（ASLR，Address Space Layout Randomization）和位置无关可执行文件（PIE，Position Independent Executables）之类的缓解措施，已经使稳定利已知漏洞的挑战的更加困难。</p>
<h2 id="1-用户空间强化-Userspace-Hardening"><a href="#1-用户空间强化-Userspace-Hardening" class="headerlink" title="1 用户空间强化(Userspace Hardening)"></a>1 用户空间强化(Userspace Hardening)</h2><p>通过用于构建软件包的默认编译器标志以及Ubuntu内核，可以启用许多安全特性。 注意：Ubuntu的编译器强化不仅适用于其官方发布的程序，也适用于使用其编译器在Ubuntu上构建的任何内容。</p>
<h3 id="1-1-栈的保护-Stack-Protector"><a href="#1-1-栈的保护-Stack-Protector" class="headerlink" title="1.1 栈的保护(Stack Protector)"></a>1.1 栈的保护(Stack Protector)</h3><p>很久之前，矿工在煤井中挖煤时，经常遇到瓦斯泄露的安全事故。后来有人发现一种鸟–金丝雀对瓦斯很敏感。于是矿工就用它作为安全报警装置。</p>
<p>Stack Protector又名canary、stack cookie等，gcc中的-fstack-protector参数提供了一个随机的栈金丝雀(stack canary)，类似于Windows平台下Visual Studio中的GS。</p>
<p>栈保护是一种针对栈缓冲区溢出攻击的缓解机制，当函数存在栈缓冲区溢出漏洞时，攻击者可以通过覆盖栈上的返回地址来执行shellcode。当启用栈保护后，调用函数前先往栈里存入一个cookie。在Linux中我们把这个cookie称为canary。当函数返回后再验证cookie是否和之前的值一致，如果不一致就终止进程。因为攻击者在覆盖返回地址的时候往往也会覆盖cookie，导致栈保护检查失败从而阻止执行任意代码。</p>
<p>在编译时可以选择是否启用栈保护以及程度，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c						 &#x2F;&#x2F; 默认情况下，不开启 Canary 保护</span><br><span class="line">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F; 禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c     &#x2F;&#x2F; 启用栈保护，只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F; 启用栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<p>绕过栈保护机制的常见方法有：泄露canary、暴破canary、劫持__stack_chk_fail、伪造canary、SSP泄露。</p>
<p>详见：</p>
<p><a href="https://www.anquanke.com/post/id/177832" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177832</a></p>
<p><a href="https://zhakul.top/archives/216" target="_blank" rel="noopener">https://zhakul.top/archives/216</a></p>
<h3 id="1-2-堆的保护-Heap-Protector"><a href="#1-2-堆的保护-Heap-Protector" class="headerlink" title="1.2 堆的保护(Heap Protector)"></a>1.2 堆的保护(Heap Protector)</h3><p>GNU C库堆保护机制（通过ptmalloc和手动两种方式自动进行）为glibc堆内存管理器（在glibc 2.3.4中首次引入）提供了对损坏列表/断开链接/双重释放/溢出( corrupted-list/unlink/double-free/overflow)的防护。 这将防止通过堆内存溢出破坏malloc堆内存区域的控制结构来执行任意代码的能力。</p>
<h3 id="1-3-指针混淆-Pointer-Obfuscation"><a href="#1-3-指针混淆-Pointer-Obfuscation" class="headerlink" title="1.3 指针混淆(Pointer Obfuscation)"></a>1.3 指针混淆(Pointer Obfuscation)</h3><p>glibc中存储的某些指针会通过glibc内部的PTR_MANGLE/PTR_UNMANGLE宏进行混淆，以防止libc函数指针在运行时被覆盖。</p>
<h3 id="1-4-不可执行内存-Non-Executable-Memory"><a href="#1-4-不可执行内存-Non-Executable-Memory" class="headerlink" title="1.4 不可执行内存(Non-Executable Memory)"></a>1.4 不可执行内存(Non-Executable Memory)</h3><p>大多数现代CPU都可以防止执行不可执行的内存区域（堆，堆栈等）。 这被称为“非eXecute（NX）”或“ eXecute-Disable（XD）”，某些BIOS制造商默认情况下会不必要地禁用它，因此请检查BIOS设置。 这种保护减少了攻击者可以用来执行任意代码执行的区域。 它要求内核使用“ PAE”寻址（也允许对3GB以上的物理地址进行寻址）。 64位和32位-server和-generic-pae内核使用PAE寻址进行编译。 从Ubuntu 9.10开始，针对在32位内核（带有或不带有PAE的内核）上运行的缺少NX的处理器，部分模拟了这种保护。</p>
<p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标记为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c					&#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c		&#x2F;&#x2F; 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c	&#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure>

<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<p>绕过NX防护手段的方法主要是ROP，详见：</p>
<p><a href="https://www.cnblogs.com/ichunqiu/p/11196219.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/11196219.html</a></p>
<h3 id="1-5-地址空间布局随机化-Address-Space-Layout-Randomisation"><a href="#1-5-地址空间布局随机化-Address-Space-Layout-Randomisation" class="headerlink" title="1.5 地址空间布局随机化(Address Space Layout Randomisation)"></a>1.5 地址空间布局随机化(Address Space Layout Randomisation)</h3><p>ASLR由内核和ELF加载器通过随机化内存分配（栈、堆、共享库等）的位置来实现。 这使得攻击者在尝试进行内存破坏利用时，内存地址更难预测。ASLR在系统范围内受/ proc / sys / kernel / randomize_va_space的值控制。 在Ubuntu 8.10之前，此选项默认为“ 1”（上）。 在包含brk ASLR的更高发行版中，它默认为“ 2”（在brk ASLR上启用）。</p>
<p>ASLR(Address space layout randomization，地址空间布局随机化)通过随机放置数据区域的地址空间来防止攻击者跳转到内存的特定位置。在 Windows 上 ASLR 主要包括堆栈随机化、PEB与TEB随机化、映像随机化，windows系统上虽然xp时代就提出来了，但是从vista开始ASLR才真正发挥作用。在linux上ASLR主要包括栈地址随机化、LIBS/MMAP随机化、EXEC随机化、BRK随机化、VDSO随机化。在没有ASLR的情况下让程序跳转到一个已经存在的系统函数的漏洞利用方式被称为ret2libc。</p>
<p>一般情况下NX（Windows平台上称其为DEP）和地址空间布局随机化（ASLR）会同时工作。可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<p>地址空间布局随机化，有以下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-栈的ASLR"><a href="#1-5-1-栈的ASLR" class="headerlink" title="1.5.1 栈的ASLR"></a>1.5.1 栈的ASLR</h4><p>每次执行程序都会有不同的栈内存空间布局。 这使得很难在内存中定位要攻击或传递可执行攻击有效负载的位置。 </p>
<h4 id="1-5-2-LIBS-MMAP的ASLR"><a href="#1-5-2-LIBS-MMAP的ASLR" class="headerlink" title="1.5.2 LIBS/MMAP的ASLR"></a>1.5.2 LIBS/MMAP的ASLR</h4><p>每次执行程序的都会产生不同的mmap内存空间布局（这会使动态加载库每次都加载到不同的内存地址）。 这使得很难在内存中找到类似“return to libc”攻击的跳转位置。</p>
<p>可以这么理解，LIBS/MMAP随机化相当于windows中dll的随机化，而EXEC随机化相当于windows中exe的随机化。</p>
<h4 id="1-5-3-EXEC的ASLR"><a href="#1-5-3-EXEC的ASLR" class="headerlink" title="1.5.3 EXEC的ASLR"></a>1.5.3 EXEC的ASLR</h4><p>使用“ -fPIE -pie”参数构建的程序的每次执行时，都将被加载到不同的内存位置。 这使得基于内存破坏的攻击，很难在内存中定位到要攻击或跳转的位置。</p>
<h4 id="1-5-4-BRK的ASLR"><a href="#1-5-4-BRK的ASLR" class="headerlink" title="1.5.4 BRK的ASLR"></a>1.5.4 BRK的ASLR</h4><p>与exec ASLR相似，brk ASLR调整exec内存区域和brk内存区域之间的相对内存位置（对于small malloc）。 在2.6.26（Ubuntu 8.10）中添加了来自exec内存的brk偏移量的随机化，尽管brk ASLR的一些影响可以在Ubuntu 8.04 LTS中的PIE程序中看到，因为exec是ASLR，并且brk在执行后立即分配 区域（因此从技术上讲是随机的，但直到8.10才相对于文本区域随机化）。</p>
<p>linux系统中brk和mmap这两个系统调用用来分配内存。当brk ASLR关闭的时候，start_brk和brk都是指向bss段的尾部的；当brk ASLR开启的时候，start_brk和brk初始位置是bss段的尾部加一个随机的偏移。</p>
<h4 id="1-5-5-VDSO的ASLR"><a href="#1-5-5-VDSO的ASLR" class="headerlink" title="1.5.5 VDSO的ASLR"></a>1.5.5 VDSO的ASLR</h4><p>程序的每次执行都会导致一个随机的vdso位置。 这样可以防止跳入系统调用(jump-into-syscall)攻击。</p>
<p>VDSO(Virtual Dynamically-linked Shared Object，虚拟动态共享库)将内核态的调用映射到用户态的地址空间中，使得调用开销更小，路径更好。拿x86下的系统调用举例，传统的int 0x80有点慢，Intel和AMD分别实现了sysenter/sysexit和syscall/sysret，即所谓的快速系统调用指令，使用它们更快，但是也带来了兼容性的问题。于是linux实现了vsyscall，程序统一调用vsyscall，具体的选择由内核来决定，vsyscall的实现就在VDSO中。执行ldd /bin/sh，会发现有个linux-vdso.so.1的动态文件，而系统中却找不到它，它就是VDSO。</p>
<h3 id="1-6-编译时强化-Built-with"><a href="#1-6-编译时强化-Built-with" class="headerlink" title="1.6 编译时强化(Built with)"></a>1.6 编译时强化(Built with)</h3><h4 id="1-6-1-编译时使用PIE参数-Built-as-PIE"><a href="#1-6-1-编译时使用PIE参数-Built-as-PIE" class="headerlink" title="1.6.1 编译时使用PIE参数(Built as PIE)"></a>1.6.1 编译时使用PIE参数(Built as PIE)</h4><p>使用“ -fPIE -pie”参数构建的位置无关可执行文件（PIE）都可以利用exec ASLR。 这样可以防止“返回文本(return-to-text)”，并且通常会阻止内存破坏攻击。 在构建整个程序包时，需要对编译器选项进行统一更改。 PIE在只有较少数量的通用寄存器（例如x86）的体系结构上会造成很大的性能损失（5-10％），因此它最初仅用于选定数量的安全关键软件包。在64位体系结构上的PIE没有相同的缺陷，并且已将其设为默认值。</p>
<p>前面说了EXEC的随机化，实际上更准确的说法是PIE(Position Independent Executables，位置无关可执行文件)。PIE只有在系统开启ASLR和编译时开启-fpie -pie选项这两个条件同时满足时才会生效。</p>
<ul>
<li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li>
</ul>
<p>位置无关的可执行文件（PIE，Position Independent Executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>
<p>liunx下关闭PIE的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -s echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br></pre></td></tr></table></figure>

<p>gcc编译命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c				&#x2F;&#x2F; 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o test test.c		&#x2F;&#x2F; 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c		&#x2F;&#x2F; 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		&#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		&#x2F;&#x2F; 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考<a href="http://writeblog.csdn.net/2009/11/20/10065/" target="_blank" rel="noopener">Gcc和Open64中的-fPIC选项</a>.</p>
<p>gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global Offset<br>Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。</p>
<p>gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。</p>
<p>绕过PIE</p>
<p><a href="https://www.cnblogs.com/ichunqiu/p/11350476.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/11350476.html</a></p>
<h4 id="1-6-2-编译时使用Fortify-Source参数-Built-with-Fortify-Source"><a href="#1-6-2-编译时使用Fortify-Source参数-Built-with-Fortify-Source" class="headerlink" title="1.6.2 编译时使用Fortify Source参数(Built with Fortify Source)"></a>1.6.2 编译时使用Fortify Source参数(Built with Fortify Source)</h4><p>使用“ -D_FORTIFY_SOURCE = 2”（以及-O1或更高版本）构建的程序在glibc中启用了几种编译时和运行时保护：</p>
<ul>
<li>当已知目的缓冲区的大小时，将对“ sprintf”，“ strcpy”的无长度限定的调用扩展为它们有长度限制的表亲函数（防止内存溢出）。</li>
<li>当格式化字符串位于可写内存段中时，阻止使用格式字化符串“％n”的攻击。</li>
<li>检查重要的函数返回值和参数（例如system，write，open）。</li>
<li>创建新文件时需要指定文件掩码。</li>
</ul>
<p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p>
<p>_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p>
<p>_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p>
<p><code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p>
<p><code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void fun(char *s) &#123;</span><br><span class="line">        char buf[0x100];</span><br><span class="line">        strcpy(buf, s);</span><br><span class="line">        &#x2F;* Don&#39;t allow gcc to optimise away the buf *&#x2F;</span><br><span class="line">        asm volatile(&quot;&quot; :: &quot;m&quot; (buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">08048450 &lt;fun&gt;:</span><br><span class="line">  push   %ebp               ; </span><br><span class="line">  mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">  sub    $0x118,%esp        ; 将0x118存储到栈上</span><br><span class="line">  mov    0x8(%ebp),%eax     ; 将目标参数载入eax</span><br><span class="line">  mov    %eax,0x4(%esp)     ; 保存目标参数</span><br><span class="line">  lea    -0x108(%ebp),%eax  ; 数组buf</span><br><span class="line">  mov    %eax,(%esp)        ; 保存</span><br><span class="line">  call   8048320 &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">  leave                     ; </span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">08048470 &lt;fun&gt;:</span><br><span class="line">  push   %ebp               ; </span><br><span class="line">  mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">  sub    $0x118,%esp        ; </span><br><span class="line">  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存</span><br><span class="line">  mov    0x8(%ebp),%eax     ; </span><br><span class="line">  mov    %eax,0x4(%esp)     ; </span><br><span class="line">  lea    -0x108(%ebp),%eax  ; </span><br><span class="line">  mov    %eax,(%esp)        ; </span><br><span class="line">  call   8048370 &lt;__strcpy_chk@plt&gt;</span><br><span class="line"></span><br><span class="line">  leave                      ; </span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<p>总结下就有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c							&#x2F;&#x2F; 默认情况下，不会开这个检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c		&#x2F;&#x2F; 较弱的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c		&#x2F;&#x2F; 较强的检查</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-编译时使用RELRO参数-Built-with-RELRO"><a href="#1-6-3-编译时使用RELRO参数-Built-with-RELRO" class="headerlink" title="1.6.3 编译时使用RELRO参数(Built with RELRO)"></a>1.6.3 编译时使用RELRO参数(Built with RELRO)</h4><p>在Linux系统安全领域数据可以写的内存区域就会是攻击的目标，尤其是存储函数指针的地方。所以从安全防护的角度来说，尽量减少可写的内存区域对安全会有极大的好处。</p>
<p>通过使加载程序将重定位表的任何区域标记为只读，以在加载时解析任何符号（“只读重定位”），从而使ELF程序防范加载程序内存区覆盖写的攻击。这减少了GOT覆盖写形式(GOT-overwrite-style)的内存破坏攻击的范围。</p>
<p>RELRO(RELocation Read-Only，只读重定位)让加载器将重定位表中加载时解析的符号标记为只读，这减少了GOT覆盖写的攻击面。RELRO可以分为部分RELRO(Partial RELRO)和完全RELRO(Full RELRO)。开启Partial RELRO的话GOT表是可写的；开启FULL RELRO的话GOT表是只读的。开启-Wl,-z,relro选项即可开启Partial RELRO；开启-Wl,-z,relro,-z,now选项即可开启Full RELRO。</p>
<p>设置符号重定位表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。当RELRO为” Partial RELRO”时，说明我们对GOT表具有写权限；如果开启FULL RELRO，意味着我们无法修改GOT表。</p>
<p>gcc编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c						&#x2F;&#x2F; 默认情况下，是 Partial RELRO</span><br><span class="line">gcc -z norelro -o test test.c			&#x2F;&#x2F; 关闭，即 No RELRO</span><br><span class="line">gcc -z lazy -o test test.c				&#x2F;&#x2F; 部分开启，即 Partial RELRO</span><br><span class="line">gcc -z now -o test test.c				&#x2F;&#x2F; 全部开启，即 FULL RELRO</span><br></pre></td></tr></table></figure>

<h4 id="1-6-4-编译时使用BIND-NOW参数-Built-with-BIND-NOW"><a href="#1-6-4-编译时使用BIND-NOW参数-Built-with-BIND-NOW" class="headerlink" title="1.6.4 编译时使用BIND_NOW参数(Built with BIND_NOW)"></a>1.6.4 编译时使用BIND_NOW参数(Built with BIND_NOW)</h4><p>标记ELF程序在启动时就解析所有动态符号（而不是”按需形式“(延时绑定)，也称为“立即绑定”），以便可以将GOT完全设为只读（与上面的RELRO结合使用时）。</p>
<h4 id="1-6-5-编译时使用fstack-clash参数-Built-with-fstack-clash-protection"><a href="#1-6-5-编译时使用fstack-clash参数-Built-with-fstack-clash-protection" class="headerlink" title="1.6.5 编译时使用fstack-clash参数(Built with -fstack-clash-protection)"></a>1.6.5 编译时使用fstack-clash参数(Built with -fstack-clash-protection)</h4><p>在可变长度栈内存分配（通过alloca()或gcc可变长度数组等）周围添加额外的指令，以在分配时探测内存的每一页。 通过确保所有栈内存分配均有效（或通过引发分段错误（如果无效）并把可能的代码执行攻击转变为拒绝服务），这可以缓解栈冲突(stack-clash)攻击。</p>
<h4 id="1-6-6-编译时使用-fcf-protection参数-Built-with-fcf-protection"><a href="#1-6-6-编译时使用-fcf-protection参数-Built-with-fcf-protection" class="headerlink" title="1.6.6 编译时使用-fcf-protection参数(Built with -fcf-protection)"></a>1.6.6 编译时使用-fcf-protection参数(Built with -fcf-protection)</h4><p>指示编译器生成指令以支持英特尔的控制流强制技术（CET,  Control-flow Enforcement Technology）。</p>
<h2 id="2-内核强化-Kernel-Hardening"><a href="#2-内核强化-Kernel-Hardening" class="headerlink" title="2 内核强化(Kernel Hardening)"></a>2 内核强化(Kernel Hardening)</h2><p>内核本身启用的保护功能，使其更难以受到威胁。</p>
<h3 id="2-1-零地址保护-0-address-protection"><a href="#2-1-零地址保护-0-address-protection" class="headerlink" title="2.1 零地址保护(0-address protection)"></a>2.1 零地址保护(0-address protection)</h3><p>由于内核和用户空间共享虚拟内存地址，因此需要对“ NULL”内存地址进行保护，以使用户空间mmap的内存无法从地址0开始，从而阻止” NULL解引用”(“NULL dereference”)内核攻击。</p>
<h3 id="2-2-dev-mem保护-dev-mem-protection"><a href="#2-2-dev-mem保护-dev-mem-protection" class="headerlink" title="2.2 /dev/mem保护(/dev/mem protection)"></a>2.2 /dev/mem保护(/dev/mem protection)</h3><p>某些应用程序（Xorg）需要从用户空间直接访问物理内存。 存在特殊文件/ dev / mem来提供此访问。 过去，如果攻击者具有root用户访问权限，则可以从该文件查看和更改内核内存。 引入了CONFIG_STRICT_DEVMEM内核选项以阻止对非设备存储器的访问。</p>
<h3 id="2-3-禁用-dev-kmem-dev-kmem-disabled"><a href="#2-3-禁用-dev-kmem-dev-kmem-disabled" class="headerlink" title="2.3 禁用/dev/kmem(/dev/kmem disabled)"></a>2.3 禁用/dev/kmem(/dev/kmem disabled)</h3><p>/ dev / kmem不再是现代用户，攻击者无法使用它来加载内核rootkit。 CONFIG_DEVKMEM设置为“ n”。 尽管/ dev / kmem设备节点通过Ubuntu 9.04在Ubuntu 8.04 LTS中仍然存在，但实际上并没有附加到内核中的任何内容。</p>
<h3 id="2-4-禁止模块加载-Block-module-loading"><a href="#2-4-禁止模块加载-Block-module-loading" class="headerlink" title="2.4 禁止模块加载(Block module loading)"></a>2.4 禁止模块加载(Block module loading)</h3><p>在Ubuntu 8.04 LTS及更早版本中，可以从系统范围的功能边界集中删除CAP_SYS_MODULES，这将阻止加载任何新的内核模块。 这是阻止安装内核rootkit的另一层保护。 2.6.25 Linux内核（Ubuntu 8.10）更改了边界集的工作方式，该功能消失了。 从Ubuntu 9.10开始，现在可以通过在/ proc / sys / kernel / modules_disabled中设置“ 1”来再次阻止模块加载。</p>
<h3 id="2-5-只读数据节-Read-only-data-sections"><a href="#2-5-只读数据节-Read-only-data-sections" class="headerlink" title="2.5 只读数据节(Read-only data sections)"></a>2.5 只读数据节(Read-only data sections)</h3><p>这样可以确保将某些内核数据段标记为禁止修改。 这有助于防止某些类的内核rootkit。 通过CONFIG_DEBUG_RODATA选项启用。</p>
<h3 id="2-6-栈的保护-Stack-protector"><a href="#2-6-栈的保护-Stack-protector" class="headerlink" title="2.6 栈的保护(Stack protector)"></a>2.6 栈的保护(Stack protector)</h3><p>类似于ELF程序用户空间中的栈保护器，内核也可以保护其内部栈。 通过CONFIG_CC_STACKPROTECTOR选项启用。</p>
<h3 id="2-7-模块只读或不可执行-Module-RO-NX"><a href="#2-7-模块只读或不可执行-Module-RO-NX" class="headerlink" title="2.7 模块只读或不可执行(Module RO/NX)"></a>2.7 模块只读或不可执行(Module RO/NX)</h3><p>此功能扩展了CONFIG_DEBUG_RODATA，对内核中已加载模块也有类似限制。 这可以帮助抵御依赖已加载模块中各种内存区域的内核攻击。通过CONFIG_DEBUG_MODULE_RONX选项启用。</p>
<h3 id="2-8-限制内核地址显示-Kernel-Address-Display-Restriction"><a href="#2-8-限制内核地址显示-Kernel-Address-Display-Restriction" class="headerlink" title="2.8 限制内核地址显示(Kernel Address Display Restriction)"></a>2.8 限制内核地址显示(Kernel Address Display Restriction)</h3><p>当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>
<h3 id="2-9-内核地址空间布局随机化-Kernel-Address-Space-Layout-Randomisation"><a href="#2-9-内核地址空间布局随机化-Kernel-Address-Space-Layout-Randomisation" class="headerlink" title="2.9 内核地址空间布局随机化(Kernel Address Space Layout Randomisation)"></a>2.9 内核地址空间布局随机化(Kernel Address Space Layout Randomisation)</h3><p>内核地址空间布局随机化（kASLR）旨在通过随机化内核的基地址来使某些内核利用更加难以实现。依赖于内核符号位置的漏洞利用必须发现随机基址。</p>
<p>kASLR从Ubuntu 14.10开始可用，但默认情况下未启用。 在内核命令行上指定“ kaslr”选项以使用kASLR。</p>
<p>注意：启用kASLR将会禁用休眠模式。</p>
<h3 id="2-10-冷门协议黑名单-Blacklist-Rare-Protocols"><a href="#2-10-冷门协议黑名单-Blacklist-Rare-Protocols" class="headerlink" title="2.10 冷门协议黑名单(Blacklist Rare Protocols)"></a>2.10 冷门协议黑名单(Blacklist Rare Protocols)</h3><p>通常，内核允许通过MODULE_ALIAS_NETPROTO（PF _…）宏按需自动加载所有网络协议。由于这些协议中的许多协议对于旧版Ubuntu用户来说都是旧的，稀有的或通常很少使用的，并且可能包含未发现的可利用漏洞，因此自Ubuntu 11.04起，它们已被列入黑名单。 其中包括：ax25，netrom，x25，rose，decnet，econet，rds和af_802154。 如果需要任何协议，则可以通过modprobe专门加载它们，或者可以更新/etc/modprobe.d/blacklist-rare-network.conf文件以删除黑名单条目。</p>
<h3 id="2-11-过滤系统调用-Syscall-Filtering"><a href="#2-11-过滤系统调用-Syscall-Filtering" class="headerlink" title="2.11 过滤系统调用(Syscall Filtering)"></a>2.11 过滤系统调用(Syscall Filtering)</h3><p>程序可以使用seccomp_filter接口过滤掉内核syscall的可用性。 这是在容器或沙箱中完成的，这些容器或沙箱希望在潜在运行不受信任的软件时进一步限制对内核接口的访问。</p>
<p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
<p>CTF中的seccomp详见：</p>
<p><a href="https://www.jianshu.com/p/969219ce9050" target="_blank" rel="noopener">https://www.jianshu.com/p/969219ce9050</a></p>
<p><a href="https://blog.csdn.net/tan6600/article/details/80967853" target="_blank" rel="noopener">https://blog.csdn.net/tan6600/article/details/80967853</a></p>
<h3 id="2-12-限制dmesg-dmesg-restrictions"><a href="#2-12-限制dmesg-dmesg-restrictions" class="headerlink" title="2.12 限制dmesg(dmesg restrictions)"></a>2.12 限制dmesg(dmesg restrictions)</h3><p>当攻击者试图开发通用性更强的漏洞利用程序时，他们经常会使用dmesg输出。通过将dmesg输出视为敏感信息，攻击者无法使用此输出。从Ubuntu 12.04 LTS开始，可以将/ proc / sys / kernel / dmesg_restrict设置为“ 1”，以将dmesg输出视为敏感内容。 Ubuntu Touch内核默认情况下启用了此功能。</p>
<h3 id="2-13-禁止kexec-Block-kexec"><a href="#2-13-禁止kexec-Block-kexec" class="headerlink" title="2.13 禁止kexec(Block kexec)"></a>2.13 禁止kexec(Block kexec)</h3><p>从Ubuntu 14.04 LTS开始，现在可以通过sysctl禁用kexec。在Ubuntu中启用了CONFIG_KEXEC，因此最终用户可以根据需要使用kexec，新的sysctl允许管理员禁用kexec_load。 例如，这在设置CONFIG_STRICT_DEVMEM和modules_disabled的环境中是理想的。</p>
<h3 id="2-14-UEFI安全启动-UEFI-Secure-Boot"><a href="#2-14-UEFI安全启动-UEFI-Secure-Boot" class="headerlink" title="2.14 UEFI安全启动(UEFI Secure Boot)"></a>2.14 UEFI安全启动(UEFI Secure Boot)</h3><p>从Ubuntu 12.04 LTS开始，UEFI安全启动在引导加载程序的强制模式和内核的非强制模式下实现。 使用此配置，无法验证的内核将只能在未启用UEFI兼容模式(quirks)下启动。Ubuntu 18.04 LTS的Ubuntu 18.04.2版本为引导加载程序和内核启用了强制模式，因此验证失败的内核不会启动，而且验证失败的内核模块也不会加载。 </p>
<h3 id="2-15-内核页表隔离-Kernel-PageTable-Isolation"><a href="#2-15-内核页表隔离-Kernel-PageTable-Isolation" class="headerlink" title="2.15 内核页表隔离(Kernel PageTable Isolation)"></a>2.15 内核页表隔离(Kernel PageTable Isolation)</h3><p>今年年初的CPU漏洞让内核页表隔离(KPTI, Kernel PageTable Isolation)进入了人们的视野。进程地址空间被分成了内核地址空间和用户地址空间，其中内核地址空间映射到了整个物理地址空间，而用户地址空间只能映射到指定的物理地址空间。内核地址空间和用户地址空间共用一个页全局目录表。为了彻底防止用户程序获取内核数据，可以令内核地址空间和用户地址空间使用两组页表集。linux内核从4.15开始支持KPTI，windows上把这个叫KVA Shadow，原理类似。更多细节请见参考资料。</p>
<h3 id="2-16-SMAP-SMEP"><a href="#2-16-SMAP-SMEP" class="headerlink" title="2.16 SMAP/SMEP"></a>2.16 SMAP/SMEP</h3><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核访问用户空间的数据和禁止内核执行用户空间的代码。arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。SMEP类似于前面说的NX，不过一个是在内核态中，一个是在用户态中。和NX一样SMAP/SMEP需要处理器支持，可以通过cat /proc/cpuinfo查看，在内核命令行中添加nosmap和nosmep禁用。windows系统从win8开始启用SMEP，windows内核枚举哪些处理器的特性可用，当它看到处理器支持SMEP时通过在CR4寄存器中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址绕过。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</p>
<p>在没有SMAP/SMEP的情况下把内核指针重定向到用户空间的漏洞利用方式被称为ret2usr。physmap是内核管理的一块非常大的连续的虚拟内存空间，为了提高效率，该空间地址和RAM地址直接映射。RAM相对physmap要小得多，导致了任何一个RAM地址都可以在physmap中找到其对应的虚拟内存地址。另一方面，我们知道用户空间的虚拟内存也会映射到RAM。这就存在两个虚拟内存地址(一个在physmap地址，一个在用户空间地址)映射到同一个RAM地址的情况。也就是说，我们在用户空间里创建的数据，代码很有可能映射到physmap空间。基于这个理论在用户空间用mmap()把提权代码映射到内存，然后再在physmap里找到其对应的副本，修改EIP跳到副本执行就可以了。因为physmap本身就是在内核空间里，所以SMAP/SMEP都不会发挥作用。这种漏洞利用方式叫ret2dir。</p>
<h2 id="3-checksec"><a href="#3-checksec" class="headerlink" title="3 checksec"></a>3 checksec</h2><p>Checksec是一个用于检查可执行文件的正在使用的标准Linux OS或PaX的安全特性（例如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）的bash脚本。 它最初是由<a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">Tobias Klein</a>编写，自2011年的v1.5版本之后，不再维护。新版本来自github.com/slimm609/的<a href="[https://github.com/slimm609/checksec.sh/](https://github.com/slimm609/checksec.sh/)">开源项目</a>。</p>
<p>[^PaX]: PaX是针对Linux Kernel的一个加固版本的补丁，它让Linux内核的内存页受限于最小权限原则，是一个”有效防御系统级别0DAY”的方案。</p>
<p>checksec的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$checksec --file&#x3D;&#x2F;bin&#x2F;ls</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE</span><br><span class="line">Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   &#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure>

<p>一般来说，也可以使用gdb中peda插件自带的checksec功能，如下图所示：</p>
<p><img src="/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/%E5%9B%BE-1.png" alt="图 1"></p>
<p>上图所示的<font color="red"><strong>CANARY: disabled</strong></font>表示没有开启栈保护特性。</p>
<h2 id="4-参考和引用"><a href="#4-参考和引用" class="headerlink" title="4 参考和引用"></a>4 参考和引用</h2><p><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>
<p><a href="https://www.infoq.cn/article/Linux-PaX-Grsecurity/" target="_blank" rel="noopener">https://www.infoq.cn/article/Linux-PaX-Grsecurity/</a></p>
<p><a href="https://blog.csdn.net/zsj2102/article/details/78734981" target="_blank" rel="noopener">https://blog.csdn.net/zsj2102/article/details/78734981</a></p>
<p><a href="https://bbs.pediy.com/thread-226696.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-226696.htm</a></p>
<p><a href="https://wiki.ubuntu.com/Security/Features" target="_blank" rel="noopener">https://wiki.ubuntu.com/Security/Features</a></p>
<p><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">https://manybutfinite.com/post/anatomy-of-a-program-in-memory/</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/" rel="prev" title="漏洞利用视角下的CVE-2020-0796漏洞">
      <i class="fa fa-chevron-left"></i> 漏洞利用视角下的CVE-2020-0796漏洞
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux系统安全缺陷缓解机制"><span class="nav-text">Linux系统安全缺陷缓解机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-用户空间强化-Userspace-Hardening"><span class="nav-text">1 用户空间强化(Userspace Hardening)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-栈的保护-Stack-Protector"><span class="nav-text">1.1 栈的保护(Stack Protector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-堆的保护-Heap-Protector"><span class="nav-text">1.2 堆的保护(Heap Protector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-指针混淆-Pointer-Obfuscation"><span class="nav-text">1.3 指针混淆(Pointer Obfuscation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-不可执行内存-Non-Executable-Memory"><span class="nav-text">1.4 不可执行内存(Non-Executable Memory)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-地址空间布局随机化-Address-Space-Layout-Randomisation"><span class="nav-text">1.5 地址空间布局随机化(Address Space Layout Randomisation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-栈的ASLR"><span class="nav-text">1.5.1 栈的ASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-LIBS-MMAP的ASLR"><span class="nav-text">1.5.2 LIBS&#x2F;MMAP的ASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-EXEC的ASLR"><span class="nav-text">1.5.3 EXEC的ASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-BRK的ASLR"><span class="nav-text">1.5.4 BRK的ASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-VDSO的ASLR"><span class="nav-text">1.5.5 VDSO的ASLR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-编译时强化-Built-with"><span class="nav-text">1.6 编译时强化(Built with)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-编译时使用PIE参数-Built-as-PIE"><span class="nav-text">1.6.1 编译时使用PIE参数(Built as PIE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-编译时使用Fortify-Source参数-Built-with-Fortify-Source"><span class="nav-text">1.6.2 编译时使用Fortify Source参数(Built with Fortify Source)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-编译时使用RELRO参数-Built-with-RELRO"><span class="nav-text">1.6.3 编译时使用RELRO参数(Built with RELRO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-4-编译时使用BIND-NOW参数-Built-with-BIND-NOW"><span class="nav-text">1.6.4 编译时使用BIND_NOW参数(Built with BIND_NOW)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-5-编译时使用fstack-clash参数-Built-with-fstack-clash-protection"><span class="nav-text">1.6.5 编译时使用fstack-clash参数(Built with -fstack-clash-protection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-6-编译时使用-fcf-protection参数-Built-with-fcf-protection"><span class="nav-text">1.6.6 编译时使用-fcf-protection参数(Built with -fcf-protection)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-内核强化-Kernel-Hardening"><span class="nav-text">2 内核强化(Kernel Hardening)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-零地址保护-0-address-protection"><span class="nav-text">2.1 零地址保护(0-address protection)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-dev-mem保护-dev-mem-protection"><span class="nav-text">2.2 &#x2F;dev&#x2F;mem保护(&#x2F;dev&#x2F;mem protection)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-禁用-dev-kmem-dev-kmem-disabled"><span class="nav-text">2.3 禁用&#x2F;dev&#x2F;kmem(&#x2F;dev&#x2F;kmem disabled)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-禁止模块加载-Block-module-loading"><span class="nav-text">2.4 禁止模块加载(Block module loading)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-只读数据节-Read-only-data-sections"><span class="nav-text">2.5 只读数据节(Read-only data sections)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-栈的保护-Stack-protector"><span class="nav-text">2.6 栈的保护(Stack protector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-模块只读或不可执行-Module-RO-NX"><span class="nav-text">2.7 模块只读或不可执行(Module RO&#x2F;NX)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-限制内核地址显示-Kernel-Address-Display-Restriction"><span class="nav-text">2.8 限制内核地址显示(Kernel Address Display Restriction)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-内核地址空间布局随机化-Kernel-Address-Space-Layout-Randomisation"><span class="nav-text">2.9 内核地址空间布局随机化(Kernel Address Space Layout Randomisation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-冷门协议黑名单-Blacklist-Rare-Protocols"><span class="nav-text">2.10 冷门协议黑名单(Blacklist Rare Protocols)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-过滤系统调用-Syscall-Filtering"><span class="nav-text">2.11 过滤系统调用(Syscall Filtering)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-限制dmesg-dmesg-restrictions"><span class="nav-text">2.12 限制dmesg(dmesg restrictions)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-禁止kexec-Block-kexec"><span class="nav-text">2.13 禁止kexec(Block kexec)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-UEFI安全启动-UEFI-Secure-Boot"><span class="nav-text">2.14 UEFI安全启动(UEFI Secure Boot)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-内核页表隔离-Kernel-PageTable-Isolation"><span class="nav-text">2.15 内核页表隔离(Kernel PageTable Isolation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-SMAP-SMEP"><span class="nav-text">2.16 SMAP&#x2F;SMEP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-checksec"><span class="nav-text">3 checksec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-参考和引用"><span class="nav-text">4 参考和引用</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stxletto</p>
  <div class="site-description" itemprop="description">安全风云波澜壮阔，对酒当歌人间值得。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/stxletto" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stxletto" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6355991245" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6355991245" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stxletto</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
