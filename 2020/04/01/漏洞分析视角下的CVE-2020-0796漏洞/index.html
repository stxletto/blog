<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.stxletto.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="漏洞分析视角下的CVE-2020-0796漏洞1. 概述 2020年3月10日是微软补丁日，安全社区注意到Microsoft发布并立即删除了有关CVE-2020-0796的信息；  2020年3月11日早上，Microsoft发布了可纠正SMBv3协议如何处理特制请求的修补程序；   2020年03月12日微软发布安全公告声称Microsoft 服务器消息块 3.1.1 (SMBv3) 协议处理某">
<meta property="og:type" content="article">
<meta property="og:title" content="漏洞分析视角下的CVE-2020-0796漏洞">
<meta property="og:url" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="深澜深蓝">
<meta property="og:description" content="漏洞分析视角下的CVE-2020-0796漏洞1. 概述 2020年3月10日是微软补丁日，安全社区注意到Microsoft发布并立即删除了有关CVE-2020-0796的信息；  2020年3月11日早上，Microsoft发布了可纠正SMBv3协议如何处理特制请求的修补程序；   2020年03月12日微软发布安全公告声称Microsoft 服务器消息块 3.1.1 (SMBv3) 协议处理某">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-1.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-2.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-3.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-4.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-5.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-6.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-7.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-8.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-9.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-10.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-11.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-12.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-13.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-14.png">
<meta property="og:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-15.png">
<meta property="article:published_time" content="2020-04-01T00:00:00.000Z">
<meta property="article:modified_time" content="2020-05-05T15:26:01.478Z">
<meta property="article:author" content="stxletto">
<meta property="article:tag" content="安全">
<meta property="article:tag" content="漏洞">
<meta property="article:tag" content="分析">
<meta property="article:tag" content="威胁">
<meta property="article:tag" content="识别">
<meta property="article:tag" content="检测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-1.png">

<link rel="canonical" href="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>漏洞分析视角下的CVE-2020-0796漏洞 | 深澜深蓝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">深澜深蓝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>作品</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stxletto.com/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stxletto">
      <meta itemprop="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深澜深蓝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          漏洞分析视角下的CVE-2020-0796漏洞
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 08:00:00" itemprop="dateCreated datePublished" datetime="2020-04-01T08:00:00+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-05 23:26:01" itemprop="dateModified" datetime="2020-05-05T23:26:01+08:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="漏洞分析视角下的CVE-2020-0796漏洞"><a href="#漏洞分析视角下的CVE-2020-0796漏洞" class="headerlink" title="漏洞分析视角下的CVE-2020-0796漏洞"></a>漏洞分析视角下的CVE-2020-0796漏洞</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><p>2020年3月10日是微软补丁日，安全社区注意到Microsoft发布并立即删除了有关CVE-2020-0796的信息；</p>
</li>
<li><p>2020年3月11日早上，Microsoft发布了可纠正SMBv3协议如何处理特制请求的修补程序； </p>
</li>
<li><p>2020年03月12日微软发布安全公告声称Microsoft 服务器消息块 3.1.1 (SMBv3) 协议处理某些请求的方式中存在远程执行代码漏洞。成功利用此漏洞的攻击者可以获取在目标服务器或客户端上执行代码的能力。要利用针对服务器的漏洞，未经身份验证的攻击者可以将特制数据包发送到目标 SMBv3 服务器。要利用针对客户端的漏洞，未经身份验证的攻击者将需要配置恶意的 SMBv3 服务器，并说服用户连接到该服务器。此安全更新通过更正 SMBv3 协议处理这些特制请求的方式来修复此漏洞。</p>
</li>
<li><p>此缺陷可影响SMB协商中的客户端和服务端。服务端漏洞位于srv2.sys中，客户端漏洞位于mrxsmb.sys中，这两个漏洞最终都在SmbCompressDecompress中调用了相同的代码。</p>
</li>
</ul>
<p>本文试以CVE-2020-0796为例，为读者呈现漏洞分析工作视角。</p>
<h2 id="2-受影响的系统"><a href="#2-受影响的系统" class="headerlink" title="2. 受影响的系统"></a>2. 受影响的系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows 10 Version 1903 for 32-bit Systems</span><br><span class="line">Windows 10 Version 1903 for ARM64-based Systems</span><br><span class="line">Windows 10 Version 1903 for x64-based Systems</span><br><span class="line">Windows 10 Version 1909 for 32-bit Systems</span><br><span class="line">Windows 10 Version 1909 for ARM64-based Systems</span><br><span class="line">Windows 10 Version 1909 for x64-based Systems</span><br><span class="line">Windows Server, version 1903 (Server Core installation)</span><br><span class="line">Windows Server, version 1909 (Server Core installation)</span><br></pre></td></tr></table></figure>

<h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h2><p>首先我们来执行CVE-2020-0796的PoC</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\admin\CVE<span class="literal">-2020</span><span class="literal">-0796</span>\&gt; python .\poc.py <span class="number">192.168</span>.<span class="number">0.10</span></span><br><span class="line">ConnectedSent negotiate packet <span class="number">1</span></span><br><span class="line">Target responded with <span class="number">452</span> bytes</span><br><span class="line">Sent negotiate packet <span class="number">2</span></span><br><span class="line">Target responded with <span class="number">534</span> bytes</span><br><span class="line">Crash bytes sent</span><br><span class="line">winexcept timed out</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-1.png" alt="img"></p>
<center>图 1</center>

<p>如果目标系统未处于调试状态，我们将观察到目标设备如图1所示进入蓝屏状态。待Windows系统重启后，我们会使用WinDBG打开C:\Windows\System32\MEMORY.DMP文件，通过分析内存转储文件尝试找到触发蓝屏的原因。</p>
<p>如果目标系统处于调试状态，将会在WinDBG中观测到如图2所示的中断：</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-2.png" alt="img"></p>
<center>图 2</center>

<h3 id="3-1-释放内存的错误"><a href="#3-1-释放内存的错误" class="headerlink" title="3.1 释放内存的错误"></a>3.1 释放内存的错误</h3><p>无论是任何一种情况，大多时候在WinDBG中首选执行!analyze -v，尝试由WinDBG自动分析导致问题的模块。</p>
<p>或者查看栈回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; kn# Child-SP          RetAddr           Call Site</span><br><span class="line">..</span><br><span class="line">0b fffff904&#96;bd3a2dd0 fffff806&#96;1b97e5ae nt!ExFreePool+0x9</span><br><span class="line">0c fffff904&#96;bd3a2e00 fffff806&#96;1b9d7f41 srvnet!SmbCompressionDecompress+0xfe</span><br><span class="line">0d fffff904&#96;bd3a2e70 fffff806&#96;1b9d699e srv2+0x17f41</span><br><span class="line">0e fffff904&#96;bd3a2ed0 fffff806&#96;1ba19a9f srv2+0x1699e</span><br><span class="line">0f fffff904&#96;bd3a2f00 fffff806&#96;1cdc496e srv2+0x59a9f</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>如上文0x0C号栈帧所示，srvnet模块中的SmbCompressionDecompress函数在调用ExFreePool时是触发蓝屏的直接因素。</p>
<p>同时，我们注意到上文0x0D号栈帧所示的返回函数是模块名+偏移量的形式，这是因为WinDBG没有加载srv2模块的的符号文件。加载srv2模块的符号之后，栈回溯更有可读性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; lml</span><br><span class="line">start             end                 module name</span><br><span class="line">..</span><br><span class="line">fffff806&#96;1b960000 fffff806&#96;1b9b3000   srvnet     (pdb symbols) c:\symbol\srvnet.pdb\CFE2BF7A30464E7FCE0CC805AA1C96CB1\srvnet.pdb</span><br><span class="line">fffff806&#96;1b9c0000 fffff806&#96;1ba85000   srv2       (pdb symbols)          c:\symbol\srv2.pdb\E423CC65395AE603B3F59D9322DB98F31\srv2.pdb</span><br><span class="line">fffff806&#96;1cc00000 fffff806&#96;1d6b5000   nt         (pdb symbols)          c:\symbol\ntkrnlmp.pdb\CE7FFB00C20B87500211456B3E905C471\ntkrnlmp.pdb</span><br><span class="line">..</span><br><span class="line"></span><br><span class="line">kd&gt; kn</span><br><span class="line"># Child-SP          RetAddr           Call Site</span><br><span class="line">00 fffff904&#96;bd3a1f28 fffff806&#96;1cea92a2 nt!DbgBreakPointWithStatus</span><br><span class="line">01 fffff904&#96;bd3a1f30 fffff806&#96;1cea8992 nt!KiBugCheckDebugBreak+0x12</span><br><span class="line">02 fffff904&#96;bd3a1f90 fffff806&#96;1cdc11a7 nt!KeBugCheck2+0x952</span><br><span class="line">03 fffff904&#96;bd3a2690 fffff806&#96;1cdd2ee9 nt!KeBugCheckEx+0x107</span><br><span class="line">04 fffff904&#96;bd3a26d0 fffff806&#96;1cdd3310 nt!KiBugCheckDispatch+0x69</span><br><span class="line">05 fffff904&#96;bd3a2810 fffff806&#96;1cdd16a5 nt!KiFastFailDispatch+0xd0</span><br><span class="line">06 fffff904&#96;bd3a29f0 fffff806&#96;1cdfa745 nt!KiRaiseSecurityCheckFailure+0x325</span><br><span class="line">07 fffff904&#96;bd3a2b88 fffff806&#96;1cc44380 nt!RtlRbRemoveNode+0x1b6145</span><br><span class="line">08 fffff904&#96;bd3a2ba0 fffff806&#96;1cc43e3a nt!RtlpHpVsChunkCoalesce+0xb0</span><br><span class="line">09 fffff904&#96;bd3a2c10 fffff806&#96;1cc460ad nt!RtlpHpVsContextFree+0x18a</span><br><span class="line">0a fffff904&#96;bd3a2cb0 fffff806&#96;1cf6e0a9 nt!ExFreeHeapPool+0x56d</span><br><span class="line">0b fffff904&#96;bd3a2dd0 fffff806&#96;1b97e5ae nt!ExFreePool+0x9</span><br><span class="line">0c fffff904&#96;bd3a2e00 fffff806&#96;1b9d7f41 srvnet!SmbCompressionDecompress+0xfe</span><br><span class="line">0d fffff904&#96;bd3a2e70 fffff806&#96;1b9d699e srv2!Srv2DecompressData+0xe1</span><br><span class="line">0e fffff904&#96;bd3a2ed0 fffff806&#96;1ba19a9f srv2!Srv2DecompressMessageAsync+0x1e</span><br><span class="line">0f fffff904&#96;bd3a2f00 fffff806&#96;1cdc496e srv2!RfspThreadPoolNodeWorkerProcessWorkItems+0x13f</span><br><span class="line">10 fffff904&#96;bd3a2f80 fffff806&#96;1cdc492c nt!KxSwitchKernelStackCallout+0x2e</span><br><span class="line">11 fffff904&#96;bd3478f0 fffff806&#96;1cc6a33e nt!KiSwitchKernelStackContinue</span><br><span class="line">12 fffff904&#96;bd347910 fffff806&#96;1cc6a13c nt!KiExpandKernelStackAndCalloutOnStackSegment+0x18e</span><br><span class="line">13 fffff904&#96;bd3479b0 fffff806&#96;1cc69fb3 nt!KiExpandKernelStackAndCalloutSwitchStack+0xdc</span><br><span class="line">14 fffff904&#96;bd347a20 fffff806&#96;1cc69f6d nt!KeExpandKernelStackAndCalloutInternal+0x33</span><br><span class="line">15 fffff904&#96;bd347a90 fffff806&#96;1ba197f7 nt!KeExpandKernelStackAndCalloutEx+0x1d</span><br><span class="line">16 fffff904&#96;bd347ad0 fffff806&#96;1d316917 srv2!RfspThreadPoolNodeWorkerRun+0x117</span><br><span class="line">17 fffff904&#96;bd347b30 fffff806&#96;1cd2a715 nt!IopThreadStart+0x37</span><br><span class="line">18 fffff904&#96;bd347b90 fffff806&#96;1cdc86ea nt!PspSystemThreadStartup+0x55</span><br><span class="line">19 fffff904&#96;bd347be0 00000000&#96;00000000 nt!KiStartSystemThread+0x2a</span><br></pre></td></tr></table></figure>

<p>根据函数名称字面理解或参考DDK文档ExFreePool是释放内存的函数，一般不会有什么问题。这个涉及Windows内核的Pool内存管理机制及结构。过往经验告诉我们，ExFreePool需要操作的内存结构被破坏掉了，即这可能是个Windows内核中的内存破坏漏洞(Memory Corruption)。</p>
<p>人生终极三问：你是谁？从哪里来？到哪里去？在漏洞分析领域同样适用。</p>
<p>为搞明白ExFreePool要释放的内存，来自哪里，又是被谁搞坏的。我们需要在IDA Pro中看看srvnet模块中的SmbCompressionDecompress函数。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-3.png" alt="img"></p>
<center>图 3</center>

<p>当然如果你那边IDA Pro显示的和图3所示不同，没有这些可读性较好的变量名，而是像图4这样</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-4.png" alt="img"></p>
<center>图 4</center>

<p>也不必惊讶，后续我们会解释，如何通过公开的文档、符号文件或者数据流，注解IDA Pro函数名或者变量名，使得显示更加友好，以便开展分析工作。这个过程有点像Windows系统自带的扫雷游戏。</p>
<p>IDA Pro显示srvnet模块中的SmbCompressionDecompress函数主要流程十分清晰：申请内存(ExAllocatePoolWithTag)、解压处理(RtlDecompressBufferEx2)、释放内存(ExFreePoolWithTag)。</p>
<p>我们现在已知蓝屏的直接原因是释放内存的操作引起的，那么问题就显然出现在成功申请内存之后，到释放内存之间的这个过程中。我们看到这个过程中只有一个处理函数，即RtlDecompressBufferEx2。</p>
<p>现在所有的疑点都集中在了RtlDecompressBufferEx2函数上，</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-5.png" alt="img"></p>
<center>图 5</center>

<p>我们来看看这个ntoskrnl模块中的RtlDecompressBufferEx2函数。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-6.png" alt="img"></p>
<center>图 6</center>

<p>在图6中IDA Pro显示RtlDecompressBufferEx2函数是根据参数CompressionFormat的一个跳转函数。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-7.png" alt="img"></p>
<center>图 7</center>

<p>RtlDecompressBufferProcs数组前2个QWORD元素为0。即当CompressionFormat取值为3时，函数最终转向RtlDecompressBufferXpressLz函数中。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-8.png" alt="img"></p>
<center>图 8</center>

<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-9.png" alt="img"></p>
<center>图 9</center>

<p>在图8和9中，IDA Pro显示RtlDecompressBufferXpressLz函数是一个300多行伪代码的复杂函数。</p>
<p>静态分析有点困难，为了快速定位问题，让我们来试试用WinDBG动态调试一下。</p>
<p>还是执行PoC，windbg中断时执行kn或者!analyze -v。这次我们试试!analyze -v。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FOLLOWUP_IP:</span><br><span class="line">nt!RtlDecompressBufferXpressLz+2d</span><br><span class="line">0fffff800&#96;4575e3c0 f3a4            rep movs byte ptr [rdi],byte ptr [rsi]</span><br><span class="line"></span><br><span class="line">FAULT_INSTR_CODE:  c085a4f3</span><br><span class="line">SYMBOL_STACK_INDEX:  7</span><br><span class="line">SYMBOL_NAME:  nt!RtlDecompressBufferXpressLz+2d0</span><br><span class="line">FOLLOWUP_NAME:  MachineOwner</span><br><span class="line">MODULE_NAME: nt</span><br><span class="line">IMAGE_NAME:  ntkrnlmp.exe</span><br><span class="line">DEBUG_FLR_IMAGE_TIMESTAMP:  0</span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line">BUCKET_ID_FUNC_OFFSET:  2d0</span><br><span class="line">FAILURE_BUCKET_ID:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br><span class="line">BUCKET_ID:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br><span class="line">PRIMARY_PROBLEM_CLASS:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br></pre></td></tr></table></figure>

<p>太棒了，我们和WinDBG达成了共识。它直接提示可能是nt!RtlDecompressBufferXpressLz+2d0处出了问题。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-10.png" alt="img"></p>
<center>图 10</center>

<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-11.png" alt="img"></p>
<center>图 11</center>

<p>如图10和11所示，现在我们了解到nt!RtlDecompressBufferXpressLz+2d0处是一个内存复制函数qmemcpy。这符合往常的漏洞构成的元素。</p>
<p>我们需要再了解一下qmemcpy里面的这3个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402f06b3000</span><br><span class="line">Pool page ffffe402f06b3000 region is Nonpaged pool</span><br><span class="line">*ffffe402f06b3000 : large page allocation, tag is LS2%, size is 0xef30 bytes</span><br><span class="line">Pooltag LS2% : LM server allocations</span><br><span class="line"></span><br><span class="line">kd&gt; !pool 0xffffe402f06b3000+0xef30</span><br><span class="line">Pool page ffffe402f06c1f30 region is Nonpaged pool</span><br><span class="line">*ffffe402f06c1f30 size:   b0 previous size:    0  (Free)      *...&amp;</span><br><span class="line">Owning component : Unknown (update pooltag.txt)</span><br><span class="line">ffffe402f06c1fe0 size: 10020 previous size:    0  (Free)       ...&amp;</span><br></pre></td></tr></table></figure>

<p>我们设置一个这样的断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2D0 &quot;.printf \&quot;RtlDecompressBufferXpressLz(), qmemcpy(dst&#x3D;0x%I64x, src&#x3D;0x%I64x, count&#x3D;0x%I64x)\&quot;, rdi, rsi, r9;.echo&quot;</span><br></pre></td></tr></table></figure>

<p>当WinDBG中断下来时，我们就能得到感兴趣的qmemcpy的3个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r</span><br><span class="line">rax&#x3D;00000000fffffffe rbx&#x3D;ffffe402e90a544f rcx&#x3D;000000008483ffff</span><br><span class="line">rdx&#x3D;ffffe40371234438 rsi&#x3D;ffffe402ec9f4438 rdi&#x3D;ffffe402ec9f4439</span><br><span class="line">rip&#x3D;fffff8015a75e3c0 rsp&#x3D;ffff890c4ed8ad98 rbp&#x3D;ffffe402ec9f4438</span><br><span class="line">r8&#x3D;ffffe402e90a5457  r9&#x3D;000000008483ffff r10&#x3D;ffffe40371234438</span><br><span class="line">r11&#x3D;ffffe402e90a5457 r12&#x3D;0000000000000000 r13&#x3D;ffffe402e373bd00</span><br><span class="line">r14&#x3D;ffffe402e90a5401 r15&#x3D;ffffe403ec9f4437</span><br><span class="line">iopl&#x3D;0         nv up ei ng nz na pe cy</span><br><span class="line">cs&#x3D;0010  ss&#x3D;0018  ds&#x3D;002b  es&#x3D;002b  fs&#x3D;0053  gs&#x3D;002b             efl&#x3D;00040283</span><br><span class="line">nt!RtlDecompressBufferXpressLz+0x2d0:</span><br><span class="line">fffff801&#96;5a75e3c0 f3a4            rep movs byte ptr [rdi],byte ptr [rsi]</span><br></pre></td></tr></table></figure>

<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmemcpy(dst&#x3D;0xffffe402ec9f4439, src&#x3D;0xffffe402ec9f4438, count&#x3D;0x8483ffff)</span><br></pre></td></tr></table></figure>

<p>查看一下目的内存的pool信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402ec9f4439</span><br><span class="line">Pool page ffffe402ec9f4439 region is Nonpaged pool</span><br><span class="line">*ffffe402ec9f4000 : large page allocation, tag is LS00, size is 0x1280 bytes</span><br><span class="line">Pooltag LS00 : SRVNET LookasideList level 0 allocation 256 Bytes, Binary : srvnet.sys</span><br></pre></td></tr></table></figure>

<p>这是一个0x1280大小的large page allocation非分页池内存。qmemcpy函数准备向其中写入<font color="red"><strong>0x8483FFFF</strong> </font>大小的数据。很显然会溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402ec9f4000+0x1280</span><br><span class="line">Pool page ffffe402ec9f5280 region is Nonpaged pool</span><br><span class="line">*ffffe402ec9f5280 size:  700 previous size:    0  (Free)      *...&amp;</span><br><span class="line">Owning component : Unknown (update pooltag.txt)</span><br><span class="line">ffffe402ec9f5990 size:  290 previous size:    0  (Allocated)  MmCi</span><br><span class="line">ffffe402ec9f5c20 size:  3c0 previous size:    0  (Free)       ...&amp;</span><br></pre></td></tr></table></figure>

<p>对于Pool内存的大小不超过一个页面长度(PAGE_SIZE，即4K字节)时，可以通过使用POOL_HEADER结构体来查看pool块信息。而对于large page allocation的内存却不行。</p>
<p>我们注意到0xffffe402ec9f4000之后在ffffe402ec9f5280 处是一个0x700大小的空闲块，再之后ffffe402ec9f5990 处是一个0x290 大小的已被分配使用的块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !poolval 0xffffe402ec9f4000+0x1280</span><br><span class="line">Pool page ffffe402ec9f5280 region is Nonpaged pool</span><br><span class="line">Validating Pool headers for pool page: ffffe402ec9f5280</span><br><span class="line">Pool page [ ffffe402ec9f5000 ] is INVALID.</span><br><span class="line">Analyzing linked list...</span><br><span class="line">[ ffffe402ec9f5000 ]: invalid previous size [ 0x41 ] should be [ 0x0 ]</span><br><span class="line">Scanning for single bit errors...</span><br><span class="line">None found</span><br></pre></td></tr></table></figure>

<p>在qmemcpy函数执行后，我们发现ffffe402ec9f5280处的_POOL_HEADER确实被写入了数据。</p>
<h3 id="3-2-复制数据的大小"><a href="#3-2-复制数据的大小" class="headerlink" title="3.2 复制数据的大小"></a>3.2 复制数据的大小</h3><p>现在我们需要搞明白，复制数据大小和目的地址的来源。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-12.png" alt="img"></p>
<center>图 12</center>

<p>经过类似的断点和调试，我们在nt!RtlDecompressBufferXpressLz+0x2AA处，观察到qmemcpy中的count数据来自于RtlDecompressBufferXpressLz收到的参数CompressedBuffer的最后4个字节与3之和（图12所示）。因此操作压缩数据末尾的4个字节，可以控制复制数据的大小。</p>
<p>复制数据大小的来源已经清楚了，就剩下最后一个谜团–目的地址的来源。</p>
<h3 id="3-3-目的地址的来源"><a href="#3-3-目的地址的来源" class="headerlink" title="3.3 目的地址的来源"></a>3.3 目的地址的来源</h3><p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-13.png" alt="img"></p>
<center>图 13</center>

<p>我们根据设置的WinDBG断点日志，整理了图13所示的函数调用及数据传递过程。也顺便介绍前文所述的如何通过公开的文档、符号文件或者数据流，注解IDA Pro函数名或者变量名，使得显示更加友好，以便开展分析工作。入手点是<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbufferex2查阅到的关于RtlDecompressBufferEx2的定义或NT之前泄露的源码中的相关函数定义。" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbufferex2查阅到的关于RtlDecompressBufferEx2的定义或NT之前泄露的源码中的相关函数定义。</a></p>
<p>从日志上来看，qmemcpy的目的地址正是UncompressedBuffer偏移1的地方。</p>
<p>Srv2DecompressData+0x85处的ExAllocatePoolWithTag() 返回值是0xffffa28f92503000，位于UncompressedBuffer之后0x370CBC8的位置。</p>
<p>即qmemcpy写入数据大小范围内有其他的Pool块时，将会导致ExFreePoolWithTag()时出错。</p>
<h3 id="3-4-任意地址写入"><a href="#3-4-任意地址写入" class="headerlink" title="3.4 任意地址写入"></a>3.4 任意地址写入</h3><p>如果size大小合适或者其范围内没有在用的Pool块，如0x1100+0n24大小时，则会有下述情况：</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-14.png" alt="img"></p>
<center>图 14</center>

<p>我们根据相关函数调用，绘制了图14所示的内存布局图。</p>
<p>当srv2!Srv2DecompressData+0x79处 SrvNetAllocateBuffer((unsigned int)(hdr.OriginalCompressedSegmentSize + offset)申请内存时，返回值设定AllocateBuf，简称A点。B点至U点正是SMB协议头中的offset值0x03e8(0n1000)。</p>
<p><img src="/2020/04/01/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-15.png" alt="img"></p>
<center>图 15</center>

<p>OriginalCompressedSegmentSize值（图15中Wireshark所示的OriginalSize）过大，与offset相加导致整数溢出。最终申请了一个较小的内存。即B点至A点的内存。内存的起始地址被写在AllocateBuf+0n24的P点。</p>
<p>当解压函数把超量数据写入U点时，如果超过了之前申请的内存（B点至A点的内存），也会覆盖原本存放在P处的指针。</p>
<p>srv2!Srv2DecompressData+0x108处的memmove会读取P点的指针作为目的地址，写入原始数据中offset之前的数据，从而完成预定的解压逻辑。当P处的指针可以被改写后，攻击者就获得了一次任意地址写入任意数据的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">srv2!memmove(Src&#x3D;0xffffcb0558c5f060, Dst&#x3D;0x4141414141414141, Size&#x3D;1000)</span><br><span class="line"></span><br><span class="line">kd&gt; db 0x0xffffcb0558c5f060</span><br><span class="line">ffffcb05&#96;58c5f060  03 03 03 03 03 03 00 00-00 00 00 00 00 00 ff ff  ................</span><br><span class="line">ffffcb05&#96;58c5f070  ff fe 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f080  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f090  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0a0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0b0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0c0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0d0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">kd&gt; !pool 0x0xffffcb0558c5f060</span><br><span class="line">Pool page ffffcb0558c5f060 region is Nonpaged pool</span><br><span class="line">*ffffcb0558c5f000 : large page allocation, tag is LS00, size is 0x1280 bytes</span><br><span class="line">Pooltag LS00 : SRVNET LookasideList level 0 allocation 256 Bytes, Binary : srvnet.sys</span><br></pre></td></tr></table></figure>

<p>至此漏洞分析视角下的工作基本完成，撰写分析报告时，我们会用倒叙的方法，就是大家经常看到的文章形式。后续文章我们再谈谈漏洞补丁分析和漏洞利用。</p>
<h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4 解决方案"></a>4 解决方案</h2><p>尽快安装微软官方补丁或在网络出入口上阻止TCP端口445，以防止SMB流量进出互联网。此外，我们建议您进行内部网络分段，并禁止终端之间的SMB连接，以防止横向移动。</p>
<p>禁用SMBv3压缩将防止利用易受攻击的SMB服务器。要禁用SMBv3压缩，可以在PowerShell中运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path  </span><br><span class="line"> &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot;</span><br><span class="line"> DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure>

<h2 id="5-综述"><a href="#5-综述" class="headerlink" title="5 综述"></a>5 综述</h2><p>此漏洞对攻击者具有很高的价值，可使得攻击者很容易触及分配内存的函数，并且可以控制触发溢出的数据大小。蓝屏(BSOD)一般是远程代码执行的前兆，从其进化到远程代码执行(RCE)会更具挑战性，因为需要借助其他漏洞以便绕过Windows最新的缓解技术(KASLR)。应警惕漏洞利用难度稍小的本地权限提升情景，请尽快安装官方补丁。</p>
<h2 id="6-参考和引用"><a href="#6-参考和引用" class="headerlink" title="6 参考和引用"></a>6 参考和引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-smb2&#x2F;1d435f21-9a21-4f4c-828e-624a176cf2a0</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-smb2&#x2F;5606ad47-5ee0-437a-817e-70c366052962</span><br><span class="line">http:&#x2F;&#x2F;yiiyee.cn&#x2F;blog&#x2F;2013&#x2F;12&#x2F;11&#x2F;large-pool-1&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;ddi&#x2F;ntifs&#x2F;nf-ntifs-rtlgetcompressionworkspacesize</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;ddi&#x2F;ntifs&#x2F;nf-ntifs-rtldecompressbufferex2</span><br></pre></td></tr></table></figure>

<h2 id="7-命令和断点"><a href="#7-命令和断点" class="headerlink" title="7 命令和断点"></a>7 命令和断点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sxe ld srv2</span><br><span class="line">!pool</span><br><span class="line">!poolval</span><br><span class="line">dt nt!_POOL_HEADER</span><br><span class="line">.writemem c:\test.log 0x20000000 L1000</span><br><span class="line">bp nt!RtlDecompressBufferEx2 &quot;.printf \&quot;RtlDecompressBufferEx2(CompressionFormat&#x3D;%d, UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;0x%I64x, UncompressedChunkSize&#x3D;0x%I64x, FinalUncompressedSize&#x3D;0x%I64x, WorkSpace&#x3D;%d)\&quot;, cl, rdx, r8d, r9, poi(rsp+0x70), poi(rsp+0x78), poi(rsp+0x80), poi(rsp+0x88);.echo;g&quot;</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2D0 &quot;.printf \&quot;RtlDecompressBufferXpressLz (), qmemcpy(dst&#x3D;0x%I64x, src&#x3D;0x%I64x, count&#x3D;0x%I64x)\&quot;, rdi, rsi, r9;.echo&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress &quot;.printf \&quot;srvnet!SmbCompressionDecompress(CompressionFormat&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;%d, UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;0x%I64x\&quot;, ecx, rdx, r8d, r9, poi(rsp+0x90);.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0x85 &quot;.printf \&quot;ExAllocatePoolWithTag(POOL_TYPE&#x3D;512, NumberOfBytes&#x3D;%d(0x%I64x), Tag&#x3D;2SL)\&quot;, edx, edx;.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0x91 &quot;.printf \&quot;ExAllocatePoolWithTag() return 0x%I64x\&quot;, rax;.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0xDF &quot;.printf \&quot;RtlDecompressBufferEx2() return0x%I64x,  FinalUncompressedSize&#x3D;%d(0x%I64x)\&quot;, ebx, poi(rsp+0x98), poi(rsp+0x98);.echo;g&quot;</span><br><span class="line">bp srvnet !SmbCompressionDecompress+0xF2 &quot;.printf \&quot;ExFreePoolWithTag(WorkSpace&#x3D;%d(0x%I64x))\&quot;, rcx, rcx;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData &quot;.printf \&quot;srv2!Srv2DecompressData(buf&#x3D;0x%I64x)\n\&quot;, rcx;db rcx L200;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x79 &quot;.printf \&quot;srv2!SrvNetAllocateBuffer(Size&#x3D;%d, Unknown&#x3D;%d) \n\&quot;, rcx, rdx;db esp+0x30 LF;dd esp+0x30 L4;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x85 &quot;.printf \&quot;srv2!SrvNetAllocateBuffer() &#x3D;0x%I64x \n\&quot;, rax;db rax;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0xEC &quot;.printf \&quot;FinalUncompressedSize&#x3D;0x%I64x, Size.m128i_i32[1]&#x3D;0x%I64x\&quot;, eax, r14d;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x108 &quot;.printf \&quot;srv2!memmove(Src&#x3D;0x%I64x, Dst&#x3D;0x%I64x,Size&#x3D;%d) \n\&quot;, rdx, rcx, r8d;db rdx;.echo&quot;</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz &quot;.printf \&quot; nt!RtlDecompressBufferXpressLz(UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;%d,0x%I64x,0x%I64x)\&quot;, rcx, edx, r8, r9d, rsp+0x38, poi(rsp+0x40);.echo;g&quot;</span><br><span class="line">bp srvnet!PplGenericAllocateFunction+0x35</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2AA</span><br><span class="line">bp srvnet!SrvNetAllocateBuffer+0xD59F&quot;.printf \&quot;srvnet!SrvNetAllocateBuffer(), SrvNetAllocateBufferFromPool()&#x3D;0x%I64x\&quot;, rax;.echo&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8-思考和讨论"><a href="#8-思考和讨论" class="headerlink" title="8 思考和讨论"></a>8 思考和讨论</h2><p>能坚持读到这里确属不易：），我们思考讨论以下3个问题有没有较好的解决办法？</p>
<ol>
<li><p>如何像查看小于PAGE_SIZE的内存使用dt nt!_POOL_HEADER那样，查看large page allocation内存的size结构？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为没有large page头部，这些“大池”中的内存页是通过“大池索引表”（nt!PoolBigPageTable）来索引跟踪的；</span><br><span class="line">而用来确认池空间拥有者的池标识同样也没有保存头部信息（因为根本就没有头部），也同样是保存在PoolBigPageTable中。</span><br><span class="line">表的每一个入口点都用一个POOL_TRACKER_BIG_PAGES结构表示。</span><br><span class="line">详见《Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool》，作者：Alex Lonescu</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于较大的内存范围，如大于8字节，使用内存访问断点？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发一个WinDBG插件，设置指定范围内存的PAGE属性，触发异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于较复杂的执行流程，从最终的数据，如何便捷的向前溯源过往有关分支？有点类似反向污点数据追踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发一个WinDBG插件若RIP不等于预期的地址，就不断的输出当前指令及寄存器状态到日志</span><br></pre></td></tr></table></figure></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/16/%E5%85%B3%E4%BA%8E%E5%8F%AF%E7%96%91%E5%9F%9F%E5%90%8Dexrnybuf.cn%E7%9A%84%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/" rel="prev" title="关于可疑域名exrnybuf.cn的溯源分析报告">
      <i class="fa fa-chevron-left"></i> 关于可疑域名exrnybuf.cn的溯源分析报告
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/21/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/" rel="next" title="漏洞利用视角下的CVE-2020-0796漏洞">
      漏洞利用视角下的CVE-2020-0796漏洞 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#漏洞分析视角下的CVE-2020-0796漏洞"><span class="nav-text">漏洞分析视角下的CVE-2020-0796漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-受影响的系统"><span class="nav-text">2. 受影响的系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-分析"><span class="nav-text">3.分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-释放内存的错误"><span class="nav-text">3.1 释放内存的错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-复制数据的大小"><span class="nav-text">3.2 复制数据的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-目的地址的来源"><span class="nav-text">3.3 目的地址的来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-任意地址写入"><span class="nav-text">3.4 任意地址写入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-解决方案"><span class="nav-text">4 解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-综述"><span class="nav-text">5 综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-参考和引用"><span class="nav-text">6 参考和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-命令和断点"><span class="nav-text">7 命令和断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-思考和讨论"><span class="nav-text">8 思考和讨论</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stxletto</p>
  <div class="site-description" itemprop="description">安全风云波澜壮阔，对酒当歌人间值得。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/stxletto" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stxletto" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6355991245" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6355991245" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stxletto</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
